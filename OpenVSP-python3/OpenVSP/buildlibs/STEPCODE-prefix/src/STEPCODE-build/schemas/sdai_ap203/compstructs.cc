/*
 * This file contains instantiation statements to create complex
 * support structures.  The structures will be used in the SCL to
 * validate user requests to instantiate complex entities.
 */

#include "complexSupport.h"
#include "sc_memmgr.h"

ComplexCollect *gencomplex()
    /*
     * This function contains instantiation statments for all the
     * ComplexLists and EntLists in a ComplexCollect.  The instan-
     * stiation statements were generated in order of lower to
     * higher, and last to first to simplify creating some of the
     * links between structures.  Because of this, the code is not
     * very readable, but does the trick.
     */
{
    ComplexCollect *cc;
    ComplexList *cl;
    EntList *node, *child;
    EntList *next[20];

    cc = new ComplexCollect;

    // ComplexList with supertype "action":
    node = new SimpleList( "directed_action" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "executed_action" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "executed_action" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "action" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "action_assignment":
    node = new SimpleList( "change" );
    next[2] = node;
    node = new SimpleList( "start_work" );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "action_assignment" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "action_request_assignment":
    node = new SimpleList( "start_request" );
    next[2] = node;
    node = new SimpleList( "change_request" );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "action_request_assignment" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "address":
    node = new SimpleList( "personal_address" );
    next[2] = node;
    node = new SimpleList( "organizational_address" );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "address" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "application_context_element":
    node = new SimpleList( "product_concept_context" );
    next[2] = node;
    node = new SimpleList( "design_context" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "product_definition_context" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "product_definition_context" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2]->prev = node;
    node->next = next[2];
    next[2] = node;
    node = new SimpleList( "mechanical_context" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "product_context" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "product_context" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "application_context_element" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "approval_assignment":
    node = new SimpleList( "cc_design_approval" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "approval_assignment" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "certification_assignment":
    node = new SimpleList( "cc_design_certification" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "certification_assignment" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "contract_assignment":
    node = new SimpleList( "cc_design_contract" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "contract_assignment" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "date":
    node = new SimpleList( "week_of_year_and_day_date" );
    next[2] = node;
    node = new SimpleList( "ordinal_date" );
    next[2]->prev = node;
    node->next = next[2];
    next[2] = node;
    node = new SimpleList( "calendar_date" );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "date" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "date_and_time_assignment":
    node = new SimpleList( "cc_design_date_and_time_assignment" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "date_and_time_assignment" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "document":
    node = new SimpleList( "document_with_class" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "document" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "document_reference":
    node = new SimpleList( "cc_design_specification_reference" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "document_reference" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "effectivity":
    node = new SimpleList( "configuration_effectivity" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "product_definition_effectivity" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "product_definition_effectivity" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2] = node;
    node = new SimpleList( "lot_effectivity" );
    next[3] = node;
    node = new SimpleList( "dated_effectivity" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "serial_numbered_effectivity" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "effectivity" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "founded_item":
    node = new SimpleList( "reparametrised_composite_curve_segment" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "composite_curve_segment" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "composite_curve_segment" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2] = node;
    node = new SimpleList( "surface_patch" );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "founded_item" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "functionally_defined_transformation":
    node = new SimpleList( "cartesian_transformation_operator_3d" );
    next[4] = node;
    node = new SimpleList( "cartesian_transformation_operator" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "cartesian_transformation_operator" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "functionally_defined_transformation" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "measure_with_unit":
    node = new SimpleList( "uncertainty_measure_with_unit" );
    next[2] = node;
    node = new SimpleList( "volume_measure_with_unit" );
    next[3] = node;
    node = new SimpleList( "area_measure_with_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "solid_angle_measure_with_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "plane_angle_measure_with_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "mass_measure_with_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "length_measure_with_unit" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "measure_with_unit" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "named_unit":
    node = new SimpleList( "volume_unit" );
    next[3] = node;
    node = new SimpleList( "area_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "solid_angle_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "plane_angle_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "mass_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "length_unit" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2] = node;
    node = new SimpleList( "context_dependent_unit" );
    next[3] = node;
    node = new SimpleList( "conversion_based_unit" );
    next[3]->prev = node;
    node->next = next[3];
    next[3] = node;
    node = new SimpleList( "si_unit" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "named_unit" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "person_and_organization_assignment":
    node = new SimpleList( "cc_design_person_and_organization_assignment" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "person_and_organization_assignment" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "product_category":
    node = new SimpleList( "product_related_product_category" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "product_category" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "product_definition":
    node = new SimpleList( "product_definition_with_associated_documents" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "product_definition" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "product_definition_formation":
    node = new SimpleList( "product_definition_formation_with_specified_source" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "product_definition_formation" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "product_definition_relationship":
    node = new SimpleList( "supplied_part_relationship" );
    next[2] = node;
    node = new SimpleList( "design_make_from_relationship" );
    next[2]->prev = node;
    node->next = next[2];
    next[2] = node;
    node = new SimpleList( "quantified_assembly_component_usage" );
    next[7] = node;
    node = new SimpleList( "promissory_usage_occurrence" );
    next[8] = node;
    node = new SimpleList( "specified_higher_usage_occurrence" );
    next[8]->prev = node;
    node->next = next[8];
    next[8] = node;
    node = new SimpleList( "next_assembly_usage_occurrence" );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "assembly_component_usage" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[5] = node;
    node = new SimpleList( "assembly_component_usage" );
    next[5]->prev = node;
    node->next = next[5];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "product_definition_usage" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "product_definition_usage" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "product_definition_relationship" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "property_definition":
    node = new SimpleList( "product_definition_shape" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "property_definition" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "property_definition_representation":
    node = new SimpleList( "shape_definition_representation" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "property_definition_representation" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "representation":
    node = new SimpleList( "definitional_representation" );
    next[2] = node;
    node = new SimpleList( "shell_based_wireframe_shape_representation" );
    next[5] = node;
    node = new SimpleList( "geometrically_bounded_surface_shape_representation" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "manifold_surface_shape_representation" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "geometrically_bounded_wireframe_shape_representation" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "edge_based_wireframe_shape_representation" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "advanced_brep_shape_representation" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "faceted_brep_shape_representation" );
    next[5]->prev = node;
    node->next = next[5];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "shape_representation" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "shape_representation" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "representation" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "representation_context":
    node = new SimpleList( "geometric_representation_context" );
    next[2] = node;
    node = new SimpleList( "global_uncertainty_assigned_context" );
    next[2]->prev = node;
    node->next = next[2];
    next[2] = node;
    node = new SimpleList( "parametric_representation_context" );
    next[2]->prev = node;
    node->next = next[2];
    next[2] = node;
    node = new SimpleList( "global_unit_assigned_context" );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "representation_context" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "representation_item":
    node = new SimpleList( "geometric_curve_set" );
    next[7] = node;
    node = new SimpleList( "geometric_set" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "geometric_set" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5] = node;
    node = new SimpleList( "edge_based_wireframe_model" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "shell_based_wireframe_model" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "shell_based_surface_model" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "brep_with_voids" );
    next[10] = node;
    node = new SimpleList( "faceted_brep" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "manifold_solid_brep" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[8] = node;
    node = new SimpleList( "manifold_solid_brep" );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "solid_model" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "solid_model" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "vertex_point" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "poly_loop" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "advanced_face" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "face_surface" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "face_surface" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "edge_curve" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "surface_replica" );
    next[8] = node;
    node = new SimpleList( "offset_surface" );
    next[8]->prev = node;
    node->next = next[8];
    next[8] = node;
    node = new SimpleList( "rectangular_composite_surface" );
    next[11] = node;
    node = new SimpleList( "curve_bounded_surface" );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "rectangular_trimmed_surface" );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "rational_b_spline_surface" );
    next[14] = node;
    node = new SimpleList( "bezier_surface" );
    next[15] = node;
    node = new SimpleList( "quasi_uniform_surface" );
    next[15]->prev = node;
    node->next = next[15];
    next[15] = node;
    node = new SimpleList( "uniform_surface" );
    next[15]->prev = node;
    node->next = next[15];
    next[15] = node;
    node = new SimpleList( "b_spline_surface_with_knots" );
    next[15]->prev = node;
    node->next = next[15];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[14]->prev = node;
    node->next = next[14];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[13] = node;
    node = new SimpleList( "b_spline_surface" );
    next[13]->prev = node;
    node->next = next[13];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[12] = node;
    node = new SimpleList( "b_spline_surface" );
    next[12]->prev = node;
    node->next = next[12];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[11]->prev = node;
    node->next = next[11];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "bounded_surface" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "bounded_surface" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8]->prev = node;
    node->next = next[8];
    next[8] = node;
    node = new SimpleList( "surface_of_revolution" );
    next[11] = node;
    node = new SimpleList( "surface_of_linear_extrusion" );
    next[11]->prev = node;
    node->next = next[11];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "swept_surface" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "swept_surface" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8]->prev = node;
    node->next = next[8];
    next[8] = node;
    node = new SimpleList( "degenerate_toroidal_surface" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[13] = node;
    node = new SimpleList( "toroidal_surface" );
    next[13]->prev = node;
    node->next = next[13];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[12] = node;
    node = new SimpleList( "toroidal_surface" );
    next[12]->prev = node;
    node->next = next[12];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[11] = node;
    node = new SimpleList( "spherical_surface" );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "conical_surface" );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "cylindrical_surface" );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "plane" );
    next[11]->prev = node;
    node->next = next[11];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "elementary_surface" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "elementary_surface" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "surface" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "surface" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "outer_boundary_curve" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[18] = node;
    node = new SimpleList( "boundary_curve" );
    next[18]->prev = node;
    node->next = next[18];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[17] = node;
    node = new SimpleList( "boundary_curve" );
    next[17]->prev = node;
    node->next = next[17];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[16] = node;
    node = new SimpleList( "composite_curve_on_surface" );
    next[16]->prev = node;
    node->next = next[16];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[15] = node;
    node = new SimpleList( "composite_curve_on_surface" );
    next[15]->prev = node;
    node->next = next[15];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[13] = node;
    node = new SimpleList( "composite_curve" );
    next[13]->prev = node;
    node->next = next[13];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[12] = node;
    node = new SimpleList( "composite_curve" );
    next[12]->prev = node;
    node->next = next[12];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[11] = node;
    node = new SimpleList( "bounded_surface_curve" );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "bounded_pcurve" );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "trimmed_curve" );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "rational_b_spline_curve" );
    next[14] = node;
    node = new SimpleList( "bezier_curve" );
    next[15] = node;
    node = new SimpleList( "quasi_uniform_curve" );
    next[15]->prev = node;
    node->next = next[15];
    next[15] = node;
    node = new SimpleList( "b_spline_curve_with_knots" );
    next[15]->prev = node;
    node->next = next[15];
    next[15] = node;
    node = new SimpleList( "uniform_curve" );
    next[15]->prev = node;
    node->next = next[15];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[14]->prev = node;
    node->next = next[14];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[13] = node;
    node = new SimpleList( "b_spline_curve" );
    next[13]->prev = node;
    node->next = next[13];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[12] = node;
    node = new SimpleList( "b_spline_curve" );
    next[12]->prev = node;
    node->next = next[12];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[11]->prev = node;
    node->next = next[11];
    next[11] = node;
    node = new SimpleList( "polyline" );
    next[11]->prev = node;
    node->next = next[11];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "bounded_curve" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "bounded_curve" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8] = node;
    node = new SimpleList( "curve_replica" );
    next[9] = node;
    node = new SimpleList( "offset_curve_3d" );
    next[9]->prev = node;
    node->next = next[9];
    next[9] = node;
    node = new SimpleList( "bounded_surface_curve" );
    next[12] = node;
    node = new SimpleList( "seam_curve" );
    next[13] = node;
    node = new SimpleList( "intersection_curve" );
    next[13]->prev = node;
    node->next = next[13];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[12]->prev = node;
    node->next = next[12];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[11] = node;
    node = new SimpleList( "surface_curve" );
    next[11]->prev = node;
    node->next = next[11];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "surface_curve" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[9]->prev = node;
    node->next = next[9];
    next[9] = node;
    node = new SimpleList( "bounded_pcurve" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[11] = node;
    node = new SimpleList( "pcurve" );
    next[11]->prev = node;
    node->next = next[11];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "pcurve" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[9]->prev = node;
    node->next = next[9];
    next[9] = node;
    node = new SimpleList( "parabola" );
    next[12] = node;
    node = new SimpleList( "hyperbola" );
    next[12]->prev = node;
    node->next = next[12];
    next[12] = node;
    node = new SimpleList( "ellipse" );
    next[12]->prev = node;
    node->next = next[12];
    next[12] = node;
    node = new SimpleList( "circle" );
    next[12]->prev = node;
    node->next = next[12];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[11] = node;
    node = new SimpleList( "conic" );
    next[11]->prev = node;
    node->next = next[11];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "conic" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[9]->prev = node;
    node->next = next[9];
    next[9] = node;
    node = new SimpleList( "line" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "curve" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "curve" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "cartesian_transformation_operator_3d" );
    next[7] = node;
    node = new SimpleList( "cartesian_transformation_operator" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "cartesian_transformation_operator" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "axis2_placement_3d" );
    next[8] = node;
    node = new SimpleList( "axis2_placement_2d" );
    next[8]->prev = node;
    node->next = next[8];
    next[8] = node;
    node = new SimpleList( "axis1_placement" );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "placement" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "placement" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "vector" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "direction" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "evaluated_degenerate_pcurve" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "degenerate_pcurve" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "degenerate_pcurve" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8] = node;
    node = new SimpleList( "point_replica" );
    next[8]->prev = node;
    node->next = next[8];
    next[8] = node;
    node = new SimpleList( "point_on_surface" );
    next[8]->prev = node;
    node->next = next[8];
    next[8] = node;
    node = new SimpleList( "point_on_curve" );
    next[8]->prev = node;
    node->next = next[8];
    next[8] = node;
    node = new SimpleList( "cartesian_point" );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "point" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "point" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "geometric_representation_item" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "geometric_representation_item" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2] = node;
    node = new SimpleList( "mapped_item" );
    next[2]->prev = node;
    node->next = next[2];
    next[2] = node;
    node = new SimpleList( "oriented_path" );
    next[9] = node;
    node = new SimpleList( "edge_loop" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8] = node;
    node = new SimpleList( "path" );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "path" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "poly_loop" );
    next[9] = node;
    node = new SimpleList( "edge_loop" );
    next[9]->prev = node;
    node->next = next[9];
    next[9] = node;
    node = new SimpleList( "vertex_loop" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8] = node;
    node = new SimpleList( "loop" );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "loop" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[5] = node;
    node = new SimpleList( "oriented_open_shell" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "open_shell" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "open_shell" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8] = node;
    node = new SimpleList( "oriented_closed_shell" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "closed_shell" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "closed_shell" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "connected_face_set" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "connected_face_set" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "connected_edge_set" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "wire_shell" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "vertex_shell" );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "oriented_face" );
    next[8] = node;
    node = new SimpleList( "advanced_face" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[10] = node;
    node = new SimpleList( "face_surface" );
    next[10]->prev = node;
    node->next = next[10];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[9] = node;
    node = new SimpleList( "face_surface" );
    next[9]->prev = node;
    node->next = next[9];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "face" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "face" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "face_outer_bound" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "face_bound" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "face_bound" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "oriented_edge" );
    next[8] = node;
    node = new SimpleList( "edge_curve" );
    next[8]->prev = node;
    node->next = next[8];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "edge" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "edge" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    next[5] = node;
    node = new SimpleList( "vertex_point" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[7] = node;
    node = new SimpleList( "vertex" );
    next[7]->prev = node;
    node->next = next[7];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[6] = node;
    node = new SimpleList( "vertex" );
    next[6]->prev = node;
    node->next = next[6];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[5]->prev = node;
    node->next = next[5];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[4] = node;
    node = new SimpleList( "topological_representation_item" );
    next[4]->prev = node;
    node->next = next[4];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next[3] = node;
    node = new SimpleList( "topological_representation_item" );
    next[3]->prev = node;
    node->next = next[3];
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "representation_item" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "representation_relationship":
    node = new SimpleList( "representation_relationship_with_transformation" );
    next[2] = node;
    node = new SimpleList( "shape_representation_relationship" );
    next[2]->prev = node;
    node->next = next[2];
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "representation_relationship" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "security_classification_assignment":
    node = new SimpleList( "cc_design_security_classification" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next[1] = node;
    node = new SimpleList( "security_classification_assignment" );
    next[1]->prev = node;
    node->next = next[1];
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    return cc;
}
