#ifndef  SDAIALL_CC
#define  SDAIALL_CC

// This file was generated by exp2cxx,
// git commit id: 0.8, build timestamp 03 Nov 2020 03:17.
// You probably don't want to edit it since your modifications
// will be lost if exp2cxx is used to regenerate it.


// in the exp2cxx source code, this file is generally referred to as files->create or createall
#include "schema.h"
#include "sc_memmgr.h"

void InitSchemasAndEnts (Registry & reg) {
    Global_rule_ptr gr;
    Where_rule_ptr wr;
    std::string str; //for large strings such as functions or global rules
// Schema:  SdaiCONFIG_CONTROL_DESIGN
    config_control_design::schema = new Schema("Config_Control_Design");
    config_control_design::schema->AssignModelContentsCreator( (ModelContentsCreator) create_SdaiModel_contents_config_control_design);
    reg.AddSchema (*config_control_design::schema);
    str.clear();
    str.append( "RULE approval_requires_approval_person_organization FOR ( approval, approval_person_organization );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( app <* approval | ( NOT ( SIZEOF( QUERY ( apo <* approval_person_organization | ( app :=: apo.\n" );
    str.append( "           authorized_approval ) ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("approval_requires_approval_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_date FOR ( date );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( dt <* date | ( NOT ( SIZEOF( USEDIN( dt, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_date",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_definition_requires_approval FOR ( product_definition, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pd <* product_definition | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( pd IN ccda.items ) ) ) \n" );
    str.append( "           = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_definition_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_definition_requires_person_organization FOR ( product_definition, cc_design_person_and_organization_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pd <* product_definition | ( NOT ( SIZEOF( QUERY ( ccdpoa <* \n" );
    str.append( "           cc_design_person_and_organization_assignment | ( pd IN ccdpoa.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_definition_requires_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE geometric_representation_item_3d FOR ( geometric_representation_item );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( gri <* geometric_representation_item | ( NOT ( ( dimension_of( gri ) = 3 ) OR ( SIZEOF( QUERY ( ur <* \n" );
    str.append( "           using_representations( gri ) | ( 'CONFIG_CONTROL_DESIGN.DEFINITIONAL_REPRESENTATION' IN TYPEOF( ur ) ) ) ) > 0 ) ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("geometric_representation_item_3d",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_approval_status FOR ( approval_status );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ast <* approval_status | ( NOT ( ast.name IN [ 'approved', 'not_yet_approved', 'disapproved', 'withdrawn'] ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_approval_status",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE certification_requires_date_time FOR ( certification, cc_design_date_and_time_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( cert <* certification | ( NOT ( SIZEOF( QUERY ( ccdta <* cc_design_date_and_time_assignment | ( cert IN \n" );
    str.append( "           ccdta.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("certification_requires_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_security_classification_level FOR ( security_classification_level );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( scl <* security_classification_level | ( NOT ( SIZEOF( USEDIN( scl, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_security_classification_level",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE security_classification_requires_person_organization FOR ( security_classification, \n" );
    str.append( "           cc_design_person_and_organization_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sc <* security_classification | ( NOT ( SIZEOF( QUERY ( ccdpoa <* \n" );
    str.append( "           cc_design_person_and_organization_assignment | ( sc IN ccdpoa.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("security_classification_requires_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE start_request_requires_date_time FOR ( start_request, cc_design_date_and_time_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sr <* start_request | ( NOT ( SIZEOF( QUERY ( ccdta <* cc_design_date_and_time_assignment | ( sr IN \n" );
    str.append( "           ccdta.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("start_request_requires_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE as_required_quantity FOR ( measure_with_unit );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( m <* measure_with_unit | ( ( 'CONFIG_CONTROL_DESIGN.DESCRIPTIVE_MEASURE' IN TYPEOF( m.value_component ) ) \n" );
    str.append( "           AND ( NOT ( m.value_component = 'as_required' ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("as_required_quantity",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_parametric_representation_context FOR ( parametric_representation_context );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( prc <* parametric_representation_context | ( NOT ( SIZEOF( USEDIN( prc, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_parametric_representation_context",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE acu_requires_security_classification FOR ( assembly_component_usage, cc_design_security_classification );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( acu <* assembly_component_usage | ( NOT ( SIZEOF( QUERY ( ccdsc <* cc_design_security_classification | \n" );
    str.append( "           ( acu IN ccdsc.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("acu_requires_security_classification",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE security_classification_requires_date_time FOR ( security_classification, cc_design_date_and_time_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sc <* security_classification | ( NOT ( SIZEOF( QUERY ( ccdta <* cc_design_date_and_time_assignment | ( \n" );
    str.append( "           ( sc IN ccdta.items ) AND ( 'classification_date' = ccdta.role.name ) ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("security_classification_requires_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE versioned_action_request_requires_solution FOR ( versioned_action_request, action_request_solution );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ar <* versioned_action_request | ( NOT ( SIZEOF( QUERY ( ars <* action_request_solution | ( ar :=: ars.\n" );
    str.append( "           request ) ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("versioned_action_request_requires_solution",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE configuration_item_requires_approval FOR ( configuration_item, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ci <* configuration_item | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( ci IN ccda.items ) ) ) \n" );
    str.append( "           = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("configuration_item_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE approval_date_time_constraints FOR ( approval_date_time );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( adt <* approval_date_time | ( NOT ( SIZEOF( TYPEOF( adt.date_time ) * [ 'CONFIG_CONTROL_DESIGN.'\n" );
    str.append( "           + 'DATE_AND_TIME' ] ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("approval_date_time_constraints",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_certification_type FOR ( certification_type );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ct <* certification_type | ( NOT ( SIZEOF( USEDIN( ct, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_certification_type",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE configuration_item_requires_person_organization FOR ( configuration_item, cc_design_person_and_organization_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ci <* configuration_item | ( NOT ( SIZEOF( QUERY ( ccdpoa <* \n" );
    str.append( "           cc_design_person_and_organization_assignment | ( ci IN ccdpoa.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("configuration_item_requires_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_action_request_status FOR ( action_request_status );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ars <* action_request_status | ( NOT ( ars.status IN [ 'proposed', 'in_work', 'issued', 'hold'] ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_action_request_status",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_concept_requires_configuration_item FOR ( product_concept, configuration_item );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pc <* product_concept | ( NOT ( SIZEOF( QUERY ( ci <* configuration_item | ( pc :=: ci.item_concept ) ) ) \n" );
    str.append( "           >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_concept_requires_configuration_item",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_security_classification_level FOR ( security_classification_level );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( scl <* security_classification_level | ( NOT ( scl.name IN [ 'unclassified', 'classified', 'proprietary', \n" );
    str.append( "           'confidential' , 'secret', 'top_secret'] ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_security_classification_level",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE change_requires_date_time FOR ( change, cc_design_date_and_time_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( chg <* change | ( NOT ( SIZEOF( QUERY ( ccdta <* cc_design_date_and_time_assignment | ( ( chg IN ccdta.\n" );
    str.append( "           items ) AND ( ccdta.role.name = 'start_date' ) ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("change_requires_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE compatible_dimension FOR ( cartesian_point, direction, representation_context, geometric_representation_context );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( x <* cartesian_point | ( SIZEOF( QUERY ( y <* geometric_representation_context | ( item_in_context( x, y ) \n" );
    str.append( "           AND ( HIINDEX( x.coordinates ) <> y.coordinate_space_dimension ) ) ) ) > 0 ) ) ) = 0 );\n" );
    str.append( "  wr2: ( SIZEOF( QUERY ( x <* direction | ( SIZEOF( QUERY ( y <* geometric_representation_context | ( item_in_context( x, y ) AND\n" );
    str.append( "           ( HIINDEX( x.direction_ratios ) <> y.coordinate_space_dimension ) ) ) ) > 0 ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("compatible_dimension",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_date_time_role FOR ( date_time_role );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( dtr <* date_time_role | ( NOT ( dtr.name IN [ 'creation_date', 'request_date', 'release_date', \n" );
    str.append( "           'start_date' , 'contract_date', 'certification_date', 'sign_off_date', 'classification_date', 'declassification_date'] ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_date_time_role",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE versioned_action_request_requires_status FOR ( versioned_action_request, action_request_status );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ar <* versioned_action_request | ( NOT ( SIZEOF( QUERY ( ars <* action_request_status | ( ar :=: ars.\n" );
    str.append( "           assigned_request ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("versioned_action_request_requires_status",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE approval_requires_approval_date_time FOR ( approval, approval_date_time );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( app <* approval | ( NOT ( SIZEOF( QUERY ( adt <* approval_date_time | ( app :=: adt.dated_approval ) ) ) \n" );
    str.append( "           = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("approval_requires_approval_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_document_type FOR ( document_type );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( dt <* document_type | ( NOT ( dt.product_data_type IN [ 'material_specification', 'process_specification', \n" );
    str.append( "           'design_specification' , 'surface_finish_specification', 'cad_filename', 'drawing'] ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_document_type",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE start_work_requires_date_time FOR ( start_work, cc_design_date_and_time_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sw <* start_work | ( NOT ( SIZEOF( QUERY ( ccdta <* cc_design_date_and_time_assignment | ( ( sw IN ccdta\n" );
    str.append( "           .items ) AND ( ccdta.role.name = 'start_date' ) ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("start_work_requires_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE no_shape_for_make_from FOR ( design_make_from_relationship );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( dmfr <* design_make_from_relationship | ( NOT ( SIZEOF( QUERY ( pd <* USEDIN( dmfr, \n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.'  + 'PROPERTY_DEFINITION.DEFINITION' ) | ( 'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN\n" );
    str.append( "           TYPEOF( pd ) ) ) ) = 0 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("no_shape_for_make_from",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_named_unit FOR ( named_unit );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( nu <* named_unit | ( NOT ( SIZEOF( USEDIN( nu, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_named_unit",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE contract_requires_approval FOR ( contract, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( c <* contract | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( c IN ccda.items ) ) ) = 1 ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("contract_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_version_requires_security_classification FOR ( product_definition_formation, cc_design_security_classification );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pdf <* product_definition_formation | ( NOT ( SIZEOF( QUERY ( ccdsc <* cc_design_security_classification\n" );
    str.append( "           | ( pdf IN ccdsc.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_version_requires_security_classification",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE subtype_mandatory_representation_context FOR ( representation_context );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( rep_cntxt <* representation_context | ( NOT ( 'CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' \n" );
    str.append( "           IN TYPEOF( rep_cntxt ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("subtype_mandatory_representation_context",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE subtype_mandatory_product_definition_usage FOR ( product_definition_usage );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pdu <* product_definition_usage | ( NOT ( ( 'CONFIG_CONTROL_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' ) IN \n" );
    str.append( "           TYPEOF( pdu ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("subtype_mandatory_product_definition_usage",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE subtype_mandatory_action FOR ( action );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( act <* action | ( NOT ( 'CONFIG_CONTROL_DESIGN.DIRECTED_ACTION' IN TYPEOF( act ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("subtype_mandatory_action",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE effectivity_requires_approval FOR ( effectivity, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( eff <* effectivity | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( eff IN ccda.items ) ) ) = 1 ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("effectivity_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_requires_person_organization FOR ( product, cc_design_person_and_organization_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( prod <* product | ( NOT ( SIZEOF( QUERY ( ccdpoa <* cc_design_person_and_organization_assignment | ( \n" );
    str.append( "           prod IN ccdpoa.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_requires_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_version_requires_approval FOR ( product_definition_formation, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pdf <* product_definition_formation | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( pdf IN ccda\n" );
    str.append( "           .items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_version_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE change_request_requires_date_time FOR ( change_request, cc_design_date_and_time_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( cr <* change_request | ( NOT ( SIZEOF( QUERY ( ccdta <* cc_design_date_and_time_assignment | ( cr IN \n" );
    str.append( "           ccdta.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("change_request_requires_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE start_request_requires_person_organization FOR ( start_request, cc_design_person_and_organization_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sr <* start_request | ( NOT ( SIZEOF( QUERY ( ccdpoa <* cc_design_person_and_organization_assignment | \n" );
    str.append( "           ( sr IN ccdpoa.items ) ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("start_request_requires_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE certification_requires_approval FOR ( certification, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( cert <* certification | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( cert IN ccda.items ) ) ) \n" );
    str.append( "           = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("certification_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_version_requires_person_organization FOR ( product_definition_formation, \n" );
    str.append( "           cc_design_person_and_organization_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pdf <* product_definition_formation | ( NOT ( SIZEOF( QUERY ( ccdpoa <* \n" );
    str.append( "           cc_design_person_and_organization_assignment | ( ( pdf IN ccdpoa.items ) AND ( ccdpoa.role.name = 'creator' ) ) ) ) = 1 ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "  wr2: ( SIZEOF( QUERY ( pdf <* product_definition_formation | ( NOT ( SIZEOF( QUERY ( ccdpoa <* \n" );
    str.append( "           cc_design_person_and_organization_assignment | ( ( pdf IN ccdpoa.items ) AND ( ccdpoa.role.name IN [ 'design_supplier', \n" );
    str.append( "           'part_supplier' ] ) ) ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_version_requires_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE contract_requires_person_organization FOR ( contract, cc_design_person_and_organization_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( c <* contract | ( NOT ( SIZEOF( QUERY ( ccdpoa <* cc_design_person_and_organization_assignment | ( c IN \n" );
    str.append( "           ccdpoa.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("contract_requires_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE no_shape_for_supplied_part FOR ( supplied_part_relationship );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( spr <* supplied_part_relationship | ( NOT ( SIZEOF( QUERY ( pd <* USEDIN( spr, 'CONFIG_CONTROL_DESIGN.' \n" );
    str.append( "           + 'PROPERTY_DEFINITION.DEFINITION' ) | ( 'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF( pd ) ) ) ) = 0 ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("no_shape_for_supplied_part",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_requires_product_category FOR ( product, product_related_product_category );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( prod <* product | ( NOT ( SIZEOF( QUERY ( prpc <* product_related_product_category | ( ( prod IN prpc.\n" );
    str.append( "           products ) AND ( prpc.name IN [ 'assembly', 'inseparable_assembly', 'detail', 'customer_furnished_equipment'] ) ) ) ) =\n" );
    str.append( "           1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_requires_product_category",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE security_classification_optional_date_time FOR ( security_classification, cc_design_date_and_time_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sc <* security_classification | ( NOT ( SIZEOF( QUERY ( ccdta <* cc_design_date_and_time_assignment | ( \n" );
    str.append( "           ( sc IN ccdta.items ) AND ( 'declassification_date' = ccdta.role.name ) ) ) ) <= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("security_classification_optional_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_product_category_value FOR ( product_related_product_category );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( prpc <* product_related_product_category | ( NOT ( prpc.name IN [ 'assembly', 'detail', \n" );
    str.append( "           'customer_furnished_equipment' , 'inseparable_assembly', 'cast', 'coined', 'drawn', 'extruded', 'forged', 'formed', \n" );
    str.append( "           'machined' , 'molded', 'rolled', 'sheared'] ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_product_category_value",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE coordinated_assembly_and_shape FOR ( next_assembly_usage_occurrence );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( nauo <* next_assembly_usage_occurrence | ( NOT assembly_shape_is_defined( nauo, 'CONFIG_CONTROL_DESIGN' ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("coordinated_assembly_and_shape",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_date_time_role FOR ( date_time_role );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( dtr <* date_time_role | ( NOT ( SIZEOF( USEDIN( dtr, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_date_time_role",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE application_context_requires_ap_definition FOR ( application_context, application_protocol_definition );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ac <* application_context | ( NOT ( SIZEOF( QUERY ( apd <* application_protocol_definition | ( ( ac :=: \n" );
    str.append( "           apd.application ) AND ( apd.application_interpreted_model_schema_name = 'config_control_design' ) ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("application_context_requires_ap_definition",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE approval_person_organization_constraints FOR ( approval_person_organization );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( apo <* approval_person_organization | ( NOT ( SIZEOF( TYPEOF( apo.person_organization ) * [\n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.PERSON_AND_ORGANIZATION' ] ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("approval_person_organization_constraints",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_shape_representation FOR ( shape_representation );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sr <* shape_representation | ( NOT ( SIZEOF( USEDIN( sr, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_shape_representation",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE global_unit_assignment FOR ( global_unit_assigned_context );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( guac <* global_unit_assigned_context | ( NOT ( SIZEOF( guac.units ) = 3 ) ) ) ) = 0 );\n" );
    str.append( "  wr2: ( SIZEOF( QUERY ( guac <* global_unit_assigned_context | ( NOT ( ( SIZEOF( QUERY ( u <* guac.units | ( \n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.LENGTH_UNIT'  IN TYPEOF( u ) ) ) ) = 1 ) AND ( SIZEOF( QUERY ( u <* guac.units | ( \n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT'  IN TYPEOF( u ) ) ) ) = 1 ) AND ( SIZEOF( QUERY ( u <* guac.units | ( \n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT'  IN TYPEOF( u ) ) ) ) = 1 ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("global_unit_assignment",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_contract_type FOR ( contract_type );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ct <* contract_type | ( NOT ( ct.description IN [ 'fixed_price', 'cost_plus'] ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_contract_type",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_contract_type FOR ( contract_type );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ct <* contract_type | ( NOT ( SIZEOF( USEDIN( ct, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_contract_type",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_approval_status FOR ( approval_status );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ast <* approval_status | ( NOT ( SIZEOF( USEDIN( ast, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_approval_status",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE change_requires_approval FOR ( change, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( chg <* change | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( chg IN ccda.items ) ) ) = 1 ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("change_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE approvals_are_assigned FOR ( approval, approval_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( app <* approval | ( NOT ( SIZEOF( QUERY ( aa <* approval_assignment | ( app :=: aa.assigned_approval ) ) ) \n" );
    str.append( "           >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("approvals_are_assigned",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_requires_version FOR ( product, product_definition_formation );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( prod <* product | ( NOT ( SIZEOF( QUERY ( pdf <* product_definition_formation | ( prod :=: pdf.\n" );
    str.append( "           of_product ) ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_requires_version",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE subtype_mandatory_effectivity FOR ( effectivity );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( eff <* effectivity | ( NOT ( ( SIZEOF( [ 'CONFIG_CONTROL_DESIGN.SERIAL_NUMBERED_EFFECTIVITY', \n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.LOT_EFFECTIVITY' , 'CONFIG_CONTROL_DESIGN.DATED_EFFECTIVITY'] * TYPEOF( eff ) ) = 1 ) AND ( \n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.CONFIGURATION_EFFECTIVITY'  IN TYPEOF( eff ) ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("subtype_mandatory_effectivity",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE start_request_requires_approval FOR ( start_request, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sr <* start_request | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( sr IN ccda.items ) ) ) = 1 ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("start_request_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE subtype_mandatory_product_context FOR ( product_context );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pc <* product_context | ( NOT ( 'CONFIG_CONTROL_DESIGN.MECHANICAL_CONTEXT' IN TYPEOF( pc ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("subtype_mandatory_product_context",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE security_classification_requires_approval FOR ( security_classification, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sc <* security_classification | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( sc IN ccda.items ) ) ) \n" );
    str.append( "           = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("security_classification_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE document_to_product_definition FOR ( cc_design_specification_reference );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sp <* cc_design_specification_reference | ( NOT ( ( ( ( 'CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +\n" );
    str.append( "           'RELATING_DOCUMENT' ) IN ROLESOF( sp\\document_reference.assigned_document ) ) AND ( SIZEOF( QUERY ( it <* sp.items | ( \n" );
    str.append( "           NOT ( 'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION' IN TYPEOF( it ) ) ) ) ) = 0 ) ) OR ( NOT ( ( 'CONFIG_CONTROL_DESIGN.'\n" );
    str.append( "           + 'DOCUMENT_RELATIONSHIP.'  + 'RELATING_DOCUMENT' ) IN ROLESOF( sp\\document_reference.assigned_document ) ) ) ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("document_to_product_definition",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE product_definition_requires_date_time FOR ( product_definition, cc_design_date_and_time_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pd <* product_definition | ( NOT ( SIZEOF( QUERY ( ccdta <* cc_design_date_and_time_assignment | ( pd IN\n" );
    str.append( "           ccdta.items ) ) ) = 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("product_definition_requires_date_time",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE unique_version_change_order_rule FOR ( change );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( c <* change | ( NOT unique_version_change_order( c.assigned_action ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("unique_version_change_order_rule",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_action_directive FOR ( action_directive );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ad <* action_directive | ( NOT ( SIZEOF( USEDIN( ad, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_action_directive",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE subtype_mandatory_representation FOR ( representation );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( rep <* representation | ( NOT ( 'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF( rep ) ) ) ) ) = \n" );
    str.append( "           0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("subtype_mandatory_representation",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE change_request_requires_approval FOR ( change_request, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( cr <* change_request | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( cr IN ccda.items ) ) ) = 1 ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("change_request_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_person_and_organization_role FOR ( person_and_organization_role );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( poar <* person_and_organization_role | ( NOT ( SIZEOF( USEDIN( poar, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_person_and_organization_role",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_document_type FOR ( document_type );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( dt <* document_type | ( NOT ( SIZEOF( USEDIN( dt, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_document_type",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_certification_type FOR ( certification_type );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ct <* certification_type | ( NOT ( ct.description IN [ 'design_supplier', 'part_supplier'] ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_certification_type",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE subtype_mandatory_product_definition_formation FOR ( product_definition_formation );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pdf <* product_definition_formation | ( NOT ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "           'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE'  ) IN TYPEOF( pdf ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("subtype_mandatory_product_definition_formation",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE change_request_requires_person_organization FOR ( change_request, cc_design_person_and_organization_assignment );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( cr <* change_request | ( NOT ( SIZEOF( QUERY ( ccpoa <* cc_design_person_and_organization_assignment | \n" );
    str.append( "           ( cr IN ccpoa.items ) ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("change_request_requires_person_organization",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE design_context_for_property FOR ( product_definition );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( pd <* product_definition | ( ( SIZEOF( USEDIN( pd, 'CONFIG_CONTROL_DESIGN.' + 'PROPERTY_DEFINITION.'\n" );
    str.append( "           + 'DEFINITION'  ) + QUERY ( pdr <* USEDIN( pd, 'CONFIG_CONTROL_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.'\n" );
    str.append( "           + 'RELATED_PRODUCT_DEFINITION'  ) | ( SIZEOF( USEDIN( pdr, 'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION.' + 'DEFINITION' ) ) \n" );
    str.append( "           >= 1 ) ) ) >= 1 ) AND ( NOT ( 'CONFIG_CONTROL_DESIGN.DESIGN_CONTEXT' IN TYPEOF( pd.frame_of_reference ) ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("design_context_for_property",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE start_work_requires_approval FOR ( start_work, cc_design_approval );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sw <* start_work | ( NOT ( SIZEOF( QUERY ( ccda <* cc_design_approval | ( sw IN ccda.items ) ) ) = 1 ) ) ) ) \n" );
    str.append( "           = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("start_work_requires_approval",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE dependent_instantiable_representation_item FOR ( representation_item );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( ri <* representation_item | ( NOT ( SIZEOF( USEDIN( ri, '' ) ) >= 1 ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("dependent_instantiable_representation_item",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE restrict_person_organization_role FOR ( person_and_organization_role );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( por <* person_and_organization_role | ( NOT ( por.name IN [ 'request_recipient', 'initiator', \n" );
    str.append( "           'part_supplier' , 'design_supplier', 'configuration_manager', 'contractor', 'classification_officer', 'creator', \n" );
    str.append( "           'design_owner' ] ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("restrict_person_organization_role",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "RULE subtype_mandatory_shape_representation FOR ( shape_representation );\n" );
    str.append( "WHERE\n" );
    str.append( "  wr1: ( SIZEOF( QUERY ( sr <* shape_representation | ( NOT ( ( SIZEOF( [ 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "           'ADVANCED_BREP_SHAPE_REPRESENTATION' , 'CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION', \n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' , 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "           'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' , 'CONFIG_CONTROL_DESIGN.' + 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION', \n" );
    str.append( "           'CONFIG_CONTROL_DESIGN.'  + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION', 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "           'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' ] * TYPEOF( sr ) ) = 1 ) OR ( SIZEOF( QUERY ( it <* sr\\\n" );
    str.append( "           representation.items | ( NOT ( 'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF( it ) ) ) ) ) = 0 ) OR ( SIZEOF( \n" );
    str.append( "           QUERY ( sdr <* QUERY ( pdr <* USEDIN( sr, 'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' + \n" );
    str.append( "           'USED_REPRESENTATION'  ) | ( 'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF( pdr ) ) ) | ( NOT ( \n" );
    str.append( "           SIZEOF( [ 'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT', 'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF( sdr.\n" );
    str.append( "           definition.definition ) ) = 1 ) ) ) ) = 0 ) ) ) ) ) = 0 );\n" );
    str.append( "END_RULE;\n" );
    str.append( "\n" );
gr = new Global_rule("subtype_mandatory_shape_representation",config_control_design::schema, str );
config_control_design::schema->AddGlobal_rule(gr);
    str.clear();
    str.append( "FUNCTION valid_time(\n" );
    str.append( "             time : local_time\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF EXISTS( time.second_component ) THEN\n" );
    str.append( "    RETURN( EXISTS( time.minute_component ) );\n" );
    str.append( "  ELSE\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION closed_shell_reversed(\n" );
    str.append( "             a_shell : closed_shell\n" );
    str.append( "         ) : oriented_closed_shell;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    the_reverse : oriented_closed_shell;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF( a_shell ) THEN\n" );
    str.append( "    the_reverse := dummy_tri || connected_face_set( a_shell\\connected_face_set.cfs_faces ) || closed_shell(  ) || \n" );
    str.append( "        oriented_closed_shell( a_shell\\oriented_closed_shell.closed_shell_element, NOT a_shell\\oriented_closed_shell.orientation );\n" );
    str.append( "  ELSE\n" );
    str.append( "    the_reverse := dummy_tri || connected_face_set( a_shell\\connected_face_set.cfs_faces ) || closed_shell(  ) || \n" );
    str.append( "        oriented_closed_shell( a_shell, FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( the_reverse );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION msb_shells(\n" );
    str.append( "             brep : manifold_solid_brep\n" );
    str.append( "         ) : SET [1 : ?] OF closed_shell;\n" );
    str.append( "  IF SIZEOF( QUERY ( msbtype <* TYPEOF( brep ) | ( msbtype LIKE '*BREP_WITH_VOIDS' ) ) ) >= 1 THEN\n" );
    str.append( "    RETURN( brep\\brep_with_voids.voids + brep.outer );\n" );
    str.append( "  ELSE\n" );
    str.append( "    RETURN( [brep.outer] );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION using_representations(\n" );
    str.append( "             item : founded_item_select\n" );
    str.append( "         ) : SET OF representation;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    results            : SET OF representation;\n" );
    str.append( "    intermediate_items : SET OF founded_item_select;\n" );
    str.append( "    result_bag         : BAG OF representation;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  results := [];\n" );
    str.append( "  result_bag := USEDIN( item, 'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS' );\n" );
    str.append( "  IF SIZEOF( result_bag ) > 0 THEN\n" );
    str.append( "    REPEAT i := 1 TO HIINDEX( result_bag ) BY 1;\n" );
    str.append( "      results := results + result_bag[i];\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  intermediate_items := using_items( item, [] );\n" );
    str.append( "  IF SIZEOF( intermediate_items ) > 0 THEN\n" );
    str.append( "    REPEAT i := 1 TO HIINDEX( intermediate_items ) BY 1;\n" );
    str.append( "      result_bag := USEDIN( intermediate_items[i], 'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS' );\n" );
    str.append( "      IF SIZEOF( result_bag ) > 0 THEN\n" );
    str.append( "        REPEAT j := 1 TO HIINDEX( result_bag ) BY 1;\n" );
    str.append( "          results := results + result_bag[j];\n" );
    str.append( "        END_REPEAT;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( results );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION bag_to_set(\n" );
    str.append( "             the_bag : BAG OF GENERIC:intype\n" );
    str.append( "         ) : SET OF GENERIC:intype;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    i       : INTEGER;\n" );
    str.append( "    the_set : SET OF GENERIC:intype := [];\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF SIZEOF( the_bag ) > 0 THEN\n" );
    str.append( "    REPEAT i := 1 TO HIINDEX( the_bag ) BY 1;\n" );
    str.append( "      the_set := the_set + the_bag[i];\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( the_set );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION build_axes(\n" );
    str.append( "             axis, ref_direction : direction\n" );
    str.append( "         ) : LIST [3 : 3] OF direction;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    d1 : direction;\n" );
    str.append( "    d2 : direction;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  d1 := NVL( normalise( axis ), dummy_gri || direction( [0, 0, 1] ) );\n" );
    str.append( "  d2 := first_proj_axis( d1, ref_direction );\n" );
    str.append( "  RETURN( [d2, normalise( cross_product( d1, d2 ) ).orientation, d1] );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION constraints_geometry_shell_based_wireframe_model(\n" );
    str.append( "             m : shell_based_wireframe_model\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    result : BOOLEAN := TRUE;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT j := 1 TO SIZEOF( m.sbwm_boundary ) BY 1;\n" );
    str.append( "    IF ( NOT ( 'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF( m.sbwm_boundary[j] ) ) ) AND ( NOT ( 'CONFIG_CONTROL_DESIGN.'\n" );
    str.append( "        + 'VERTEX_SHELL'  IN TYPEOF( m.sbwm_boundary[j] ) ) ) THEN\n" );
    str.append( "      result := FALSE;\n" );
    str.append( "      RETURN( result );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION scalar_times_vector(\n" );
    str.append( "             scalar : REAL;\n" );
    str.append( "             vec : vector_or_direction\n" );
    str.append( "         ) : vector;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    v      : direction;\n" );
    str.append( "    mag    : REAL;\n" );
    str.append( "    result : vector;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF ( NOT EXISTS( scalar ) ) OR ( NOT EXISTS( vec ) ) THEN\n" );
    str.append( "    RETURN( ? );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF( vec ) THEN\n" );
    str.append( "      v := dummy_gri || direction( vec.orientation.direction_ratios );\n" );
    str.append( "      mag := scalar * vec.magnitude;\n" );
    str.append( "    ELSE\n" );
    str.append( "      v := dummy_gri || direction( vec.direction_ratios );\n" );
    str.append( "      mag := scalar;\n" );
    str.append( "    END_IF;\n" );
    str.append( "    IF mag < 0 THEN\n" );
    str.append( "      REPEAT i := 1 TO SIZEOF( v.direction_ratios ) BY 1;\n" );
    str.append( "        v.direction_ratios[i] := -v.direction_ratios[i];\n" );
    str.append( "      END_REPEAT;\n" );
    str.append( "      mag := -mag;\n" );
    str.append( "    END_IF;\n" );
    str.append( "    result := dummy_gri || vector( normalise( v ), mag );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION valid_geometrically_bounded_wf_curve(\n" );
    str.append( "             crv : curve\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.POLYLINE', 'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE', 'CONFIG_CONTROL_DESIGN.ELLIPSE', \n" );
    str.append( "      'CONFIG_CONTROL_DESIGN.CIRCLE' ] * TYPEOF( crv ) ) = 1 THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF( crv ) THEN\n" );
    str.append( "      IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.LINE', 'CONFIG_CONTROL_DESIGN.PARABOLA', 'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF( \n" );
    str.append( "          crv\\trimmed_curve.basis_curve ) ) = 1 THEN\n" );
    str.append( "        RETURN( TRUE );\n" );
    str.append( "      ELSE\n" );
    str.append( "        RETURN( valid_geometrically_bounded_wf_curve( crv\\trimmed_curve.basis_curve ) );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF( crv ) THEN\n" );
    str.append( "        RETURN( valid_geometrically_bounded_wf_curve( crv\\offset_curve_3d.basis_curve ) );\n" );
    str.append( "      ELSE\n" );
    str.append( "        IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF( crv ) THEN\n" );
    str.append( "          RETURN( valid_geometrically_bounded_wf_curve( crv\\curve_replica.parent_curve ) );\n" );
    str.append( "        ELSE\n" );
    str.append( "          IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF( crv ) THEN\n" );
    str.append( "            RETURN( SIZEOF( QUERY ( ccs <* crv\\composite_curve.segments | ( NOT valid_geometrically_bounded_wf_curve( ccs.\n" );
    str.append( "                parent_curve ) ) ) ) = 0 );\n" );
    str.append( "          END_IF;\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION valid_wireframe_edge_curve(\n" );
    str.append( "             crv : curve\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.LINE', 'CONFIG_CONTROL_DESIGN.CONIC', 'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE', \n" );
    str.append( "      'CONFIG_CONTROL_DESIGN.POLYLINE' ] * TYPEOF( crv ) ) = 1 THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF( crv ) THEN\n" );
    str.append( "      RETURN( valid_wireframe_edge_curve( crv\\curve_replica.parent_curve ) );\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF( crv ) THEN\n" );
    str.append( "        RETURN( valid_wireframe_edge_curve( crv\\offset_curve_3d.basis_curve ) );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION leap_year(\n" );
    str.append( "             year : year_number\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF ( ( ( year MOD 4 ) = 0 ) AND ( ( year MOD 100 ) <> 0 ) ) OR ( ( year MOD 400 ) = 0 ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION orthogonal_complement(\n" );
    str.append( "             vec : direction\n" );
    str.append( "         ) : direction;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    result : direction;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF ( vec.dim <> 2 ) OR ( NOT EXISTS( vec ) ) THEN\n" );
    str.append( "    RETURN( ? );\n" );
    str.append( "  ELSE\n" );
    str.append( "    result := dummy_gri || direction( [-vec.direction_ratios[2], vec.direction_ratios[1]] );\n" );
    str.append( "    RETURN( result );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION gbsf_check_curve(\n" );
    str.append( "             cv : curve\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.BOUNDED_CURVE', 'CONFIG_CONTROL_DESIGN.CONIC', 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA', \n" );
    str.append( "      'CONFIG_CONTROL_DESIGN.LINE' , 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] * TYPEOF( cv ) ) > 1 THEN\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.CIRCLE', 'CONFIG_CONTROL_DESIGN.ELLIPSE'] * TYPEOF( cv ) ) = 1 THEN\n" );
    str.append( "      RETURN( TRUE );\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF ( ( 'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF( cv ) ) AND ( cv\\b_spline_curve.self_intersect = FALSE ) ) OR ( cv\\\n" );
    str.append( "          b_spline_curve.self_intersect = UNKNOWN ) THEN\n" );
    str.append( "        RETURN( TRUE );\n" );
    str.append( "      ELSE\n" );
    str.append( "        IF ( ( 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF( cv ) ) AND ( cv\\composite_curve.self_intersect = FALSE ) ) OR \n" );
    str.append( "            ( cv\\composite_curve.self_intersect = UNKNOWN ) THEN\n" );
    str.append( "          RETURN( SIZEOF( QUERY ( seg <* cv\\composite_curve.segments | ( NOT gbsf_check_curve( seg.parent_curve ) ) ) ) = 0 );\n" );
    str.append( "        ELSE\n" );
    str.append( "          IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF( cv ) THEN\n" );
    str.append( "            RETURN( gbsf_check_curve( cv\\curve_replica.parent_curve ) );\n" );
    str.append( "          ELSE\n" );
    str.append( "            IF ( 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF( cv ) ) AND ( ( cv\\offset_curve_3d.self_intersect = FALSE ) OR\n" );
    str.append( "                ( cv\\offset_curve_3d.self_intersect = UNKNOWN ) ) AND ( NOT ( 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF( cv.\n" );
    str.append( "                basis_curve ) ) ) THEN\n" );
    str.append( "              RETURN( gbsf_check_curve( cv\\offset_curve_3d.basis_curve ) );\n" );
    str.append( "            ELSE\n" );
    str.append( "              IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF( cv ) THEN\n" );
    str.append( "                RETURN( gbsf_check_curve( cv\\pcurve.reference_to_curve\\representation.items[1] ) AND gbsf_check_surface( cv\\\n" );
    str.append( "                    pcurve.basis_surface ) );\n" );
    str.append( "              ELSE\n" );
    str.append( "                IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF( cv ) THEN\n" );
    str.append( "                  IF SIZEOF( cv\\polyline.points ) >= 3 THEN\n" );
    str.append( "                    RETURN( TRUE );\n" );
    str.append( "                  END_IF;\n" );
    str.append( "                ELSE\n" );
    str.append( "                  IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF( cv ) THEN\n" );
    str.append( "                    IF gbsf_check_curve( cv\\surface_curve.curve_3d ) THEN\n" );
    str.append( "                      REPEAT i := 1 TO SIZEOF( cv\\surface_curve.associated_geometry ) BY 1;\n" );
    str.append( "                        IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF( cv\\surface_curve.associated_geometry[i] ) THEN\n" );
    str.append( "                          IF NOT gbsf_check_surface( cv\\surface_curve.associated_geometry[i] ) THEN\n" );
    str.append( "                            RETURN( FALSE );\n" );
    str.append( "                          END_IF;\n" );
    str.append( "                        ELSE\n" );
    str.append( "                          IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF( cv\\surface_curve.associated_geometry[i] ) THEN\n" );
    str.append( "                            IF NOT gbsf_check_curve( cv\\surface_curve.associated_geometry[i] ) THEN\n" );
    str.append( "                              RETURN( FALSE );\n" );
    str.append( "                            END_IF;\n" );
    str.append( "                          END_IF;\n" );
    str.append( "                        END_IF;\n" );
    str.append( "                      END_REPEAT;\n" );
    str.append( "                      RETURN( TRUE );\n" );
    str.append( "                    END_IF;\n" );
    str.append( "                  ELSE\n" );
    str.append( "                    IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF( cv ) THEN\n" );
    str.append( "                      IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.LINE', 'CONFIG_CONTROL_DESIGN.PARABOLA', 'CONFIG_CONTROL_DESIGN.'\n" );
    str.append( "                          + 'HYPERBOLA' ] * TYPEOF( cv\\trimmed_curve.basis_curve ) ) = 1 THEN\n" );
    str.append( "                        RETURN( TRUE );\n" );
    str.append( "                      ELSE\n" );
    str.append( "                        RETURN( gbsf_check_curve( cv\\trimmed_curve.basis_curve ) );\n" );
    str.append( "                      END_IF;\n" );
    str.append( "                    END_IF;\n" );
    str.append( "                  END_IF;\n" );
    str.append( "                END_IF;\n" );
    str.append( "              END_IF;\n" );
    str.append( "            END_IF;\n" );
    str.append( "          END_IF;\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION valid_wireframe_vertex_point(\n" );
    str.append( "             pnt : point\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF( pnt ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF( pnt ) THEN\n" );
    str.append( "      RETURN( valid_wireframe_vertex_point( pnt\\point_replica.parent_pt ) );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION normalise(\n" );
    str.append( "             arg : vector_or_direction\n" );
    str.append( "         ) : vector_or_direction;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    ndim   : INTEGER;\n" );
    str.append( "    v      : direction;\n" );
    str.append( "    vec    : vector;\n" );
    str.append( "    mag    : REAL;\n" );
    str.append( "    result : vector_or_direction;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF NOT EXISTS( arg ) THEN\n" );
    str.append( "    result := ?;\n" );
    str.append( "  ELSE\n" );
    str.append( "    ndim := arg.dim;\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF( arg ) THEN\n" );
    str.append( "      BEGIN\n" );
    str.append( "        v := dummy_gri || direction( arg.orientation.direction_ratios );\n" );
    str.append( "        IF arg.magnitude = 0 THEN\n" );
    str.append( "          RETURN( ? );\n" );
    str.append( "        ELSE\n" );
    str.append( "          vec := dummy_gri || vector( v, 1 );\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END;\n" );
    str.append( "    ELSE\n" );
    str.append( "      v := dummy_gri || direction( arg.direction_ratios );\n" );
    str.append( "    END_IF;\n" );
    str.append( "    mag := 0;\n" );
    str.append( "    REPEAT i := 1 TO ndim BY 1;\n" );
    str.append( "      mag := mag + ( v.direction_ratios[i] * v.direction_ratios[i] );\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "    IF mag > 0 THEN\n" );
    str.append( "      mag := SQRT( mag );\n" );
    str.append( "      REPEAT i := 1 TO ndim BY 1;\n" );
    str.append( "        v.direction_ratios[i] := v.direction_ratios[i] / mag;\n" );
    str.append( "      END_REPEAT;\n" );
    str.append( "      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF( arg ) THEN\n" );
    str.append( "        vec.orientation := v;\n" );
    str.append( "        result := vec;\n" );
    str.append( "      ELSE\n" );
    str.append( "        result := v;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    ELSE\n" );
    str.append( "      RETURN( ? );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION derive_dimensional_exponents(\n" );
    str.append( "             x : unit\n" );
    str.append( "         ) : dimensional_exponents;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    i      : INTEGER;\n" );
    str.append( "    result : dimensional_exponents := dimensional_exponents( 0, 0, 0, 0, 0, 0, 0 );\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  result := x.dimensions;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION acyclic_product_definition_relationship(\n" );
    str.append( "             relation : product_definition_relationship;\n" );
    str.append( "             relatives : SET [1 : ?] OF product_definition;\n" );
    str.append( "             specific_relation : STRING\n" );
    str.append( "         ) : LOGICAL;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    x : SET OF product_definition_relationship;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF relation.relating_product_definition IN relatives THEN\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  x := QUERY ( pd <* bag_to_set( USEDIN( relation.relating_product_definition, 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "      'PRODUCT_DEFINITION_RELATIONSHIP.'  + 'RELATED_PRODUCT_DEFINITION' ) ) | ( specific_relation IN TYPEOF( pd ) ) );\n" );
    str.append( "  REPEAT i := 1 TO HIINDEX( x ) BY 1;\n" );
    str.append( "    IF NOT acyclic_product_definition_relationship( x[i], relatives + relation.relating_product_definition, specific_relation )\n" );
    str.append( "        THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION make_array_of_array(\n" );
    str.append( "             lis : LIST [1 : ?] OF LIST [1 : ?] OF GENERIC:t;\n" );
    str.append( "             low1, u1, low2, u2 : INTEGER\n" );
    str.append( "         ) : ARRAY OF ARRAY OF GENERIC:t;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    res : ARRAY [low1 : u1] OF ARRAY [low2 : u2] OF GENERIC:t;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF ( ( u1 - low1 ) + 1 ) <> SIZEOF( lis ) THEN\n" );
    str.append( "    RETURN( ? );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF ( ( u2 - low2 ) + 1 ) <> SIZEOF( lis[1] ) THEN\n" );
    str.append( "    RETURN( ? );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  res := [list_to_array( lis[1], low2, u2 ), ( u1 - low1 ) + 1];\n" );
    str.append( "  REPEAT i := 2 TO HIINDEX( lis ) BY 1;\n" );
    str.append( "    IF ( ( u2 - low2 ) + 1 ) <> SIZEOF( lis[i] ) THEN\n" );
    str.append( "      RETURN( ? );\n" );
    str.append( "    END_IF;\n" );
    str.append( "    res[( low1 + i ) - 1] := list_to_array( lis[i], low2, u2 );\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( res );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION build_2axes(\n" );
    str.append( "             ref_direction : direction\n" );
    str.append( "         ) : LIST [2 : 2] OF direction;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    d : direction := NVL( normalise( ref_direction ), dummy_gri || direction( [1, 0] ) );\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  RETURN( [d, orthogonal_complement( d )] );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION mixed_loop_type_set(\n" );
    str.append( "             l : SET [0 : ?] OF loop\n" );
    str.append( "         ) : LOGICAL;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    poly_loop_type : LOGICAL;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF SIZEOF( l ) <= 1 THEN\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  poly_loop_type := 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF( l[1] );\n" );
    str.append( "  REPEAT i := 2 TO SIZEOF( l ) BY 1;\n" );
    str.append( "    IF ( 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF( l[i] ) ) <> poly_loop_type THEN\n" );
    str.append( "      RETURN( TRUE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION second_proj_axis(\n" );
    str.append( "             z_axis, x_axis, arg : direction\n" );
    str.append( "         ) : direction;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    temp   : vector;\n" );
    str.append( "    v      : direction;\n" );
    str.append( "    y_axis : vector;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF NOT EXISTS( arg ) THEN\n" );
    str.append( "    v := dummy_gri || direction( [0, 1, 0] );\n" );
    str.append( "  ELSE\n" );
    str.append( "    v := arg;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  temp := scalar_times_vector( dot_product( v, z_axis ), z_axis );\n" );
    str.append( "  y_axis := vector_difference( v, temp );\n" );
    str.append( "  temp := scalar_times_vector( dot_product( v, x_axis ), x_axis );\n" );
    str.append( "  y_axis := vector_difference( y_axis, temp );\n" );
    str.append( "  y_axis := normalise( y_axis );\n" );
    str.append( "  RETURN( y_axis.orientation );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION path_head_to_tail(\n" );
    str.append( "             a_path : path\n" );
    str.append( "         ) : LOGICAL;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    n : INTEGER;\n" );
    str.append( "    p : BOOLEAN := TRUE;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  n := SIZEOF( a_path.edge_list );\n" );
    str.append( "  REPEAT i := 2 TO n BY 1;\n" );
    str.append( "    p := p AND ( a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i].edge_start );\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( p );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION set_of_topology_reversed(\n" );
    str.append( "             a_set : set_of_reversible_topology_item\n" );
    str.append( "         ) : set_of_reversible_topology_item;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    the_reverse : set_of_reversible_topology_item;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  the_reverse := [];\n" );
    str.append( "  REPEAT i := 1 TO SIZEOF( a_set ) BY 1;\n" );
    str.append( "    the_reverse := the_reverse + topology_reversed( a_set[i] );\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( the_reverse );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION valid_calendar_date(\n" );
    str.append( "             date : calendar_date\n" );
    str.append( "         ) : LOGICAL;\n" );
    str.append( "  IF NOT ( ( 1 <= date.day_component ) AND ( date.day_component <= 31 ) ) THEN\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  CASE date.month_component OF\n" );
    str.append( "    4        :       RETURN( ( 1 <= date.day_component ) AND ( date.day_component <= 30 ) );\n" );
    str.append( "    6        :       RETURN( ( 1 <= date.day_component ) AND ( date.day_component <= 30 ) );\n" );
    str.append( "    9        :       RETURN( ( 1 <= date.day_component ) AND ( date.day_component <= 30 ) );\n" );
    str.append( "    11       :       RETURN( ( 1 <= date.day_component ) AND ( date.day_component <= 30 ) );\n" );
    str.append( "    2        : \n" );
    str.append( "      BEGIN\n" );
    str.append( "        IF leap_year( date.year_component ) THEN\n" );
    str.append( "          RETURN( ( 1 <= date.day_component ) AND ( date.day_component <= 29 ) );\n" );
    str.append( "        ELSE\n" );
    str.append( "          RETURN( ( 1 <= date.day_component ) AND ( date.day_component <= 28 ) );\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END;\n" );
    str.append( "    OTHERWISE  :       RETURN( TRUE );\n" );
    str.append( "    END_CASE;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION curve_weights_positive(\n" );
    str.append( "             b : rational_b_spline_curve\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    result : BOOLEAN := TRUE;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT i := 0 TO b.upper_index_on_control_points BY 1;\n" );
    str.append( "    IF b.weights[i] <= 0 THEN\n" );
    str.append( "      result := FALSE;\n" );
    str.append( "      RETURN( result );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION list_face_loops(\n" );
    str.append( "             f : face\n" );
    str.append( "         ) : LIST [0 : ?] OF loop;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    loops : LIST [0 : ?] OF loop := [];\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT i := 1 TO SIZEOF( f.bounds ) BY 1;\n" );
    str.append( "    loops := loops + f.bounds[i].bound;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( loops );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION gbsf_check_surface(\n" );
    str.append( "             sf : surface\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF ( ( 'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF( sf ) ) AND ( sf\\b_spline_surface.self_intersect = FALSE ) ) OR ( sf\\\n" );
    str.append( "      b_spline_surface.self_intersect = UNKNOWN ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE', 'CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'] * TYPEOF( sf ) ) = 1 THEN\n" );
    str.append( "      RETURN( TRUE );\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF 'CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF( sf ) THEN\n" );
    str.append( "        IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.CONICAL_SURFACE', 'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE', 'CONFIG_CONTROL_DESIGN.'\n" );
    str.append( "            + 'PLANE' ] * TYPEOF( sf\\curve_bounded_surface.basis_surface ) ) = 1 THEN\n" );
    str.append( "          RETURN( SIZEOF( QUERY ( bcurve <* sf\\curve_bounded_surface.boundaries | ( NOT gbsf_check_curve( bcurve ) ) ) ) = 0 );\n" );
    str.append( "        ELSE\n" );
    str.append( "          IF gbsf_check_surface( sf\\curve_bounded_surface.basis_surface ) THEN\n" );
    str.append( "            RETURN( SIZEOF( QUERY ( bcurve <* sf\\curve_bounded_surface.boundaries | ( NOT gbsf_check_curve( bcurve ) ) ) ) = 0 );\n" );
    str.append( "          END_IF;\n" );
    str.append( "        END_IF;\n" );
    str.append( "      ELSE\n" );
    str.append( "        IF ( ( 'CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF( sf ) ) AND ( sf\\offset_surface.self_intersect = FALSE ) ) OR ( \n" );
    str.append( "            sf\\offset_surface.self_intersect = UNKNOWN ) THEN\n" );
    str.append( "          RETURN( gbsf_check_surface( sf\\offset_surface.basis_surface ) );\n" );
    str.append( "        ELSE\n" );
    str.append( "          IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF( sf ) THEN\n" );
    str.append( "            REPEAT i := 1 TO SIZEOF( sf\\rectangular_composite_surface.segments ) BY 1;\n" );
    str.append( "              REPEAT j := 1 TO SIZEOF( sf\\rectangular_composite_surface.segments[i] ) BY 1;\n" );
    str.append( "                IF NOT gbsf_check_surface( sf\\rectangular_composite_surface.segments[i][j].parent_surface ) THEN\n" );
    str.append( "                  RETURN( FALSE );\n" );
    str.append( "                END_IF;\n" );
    str.append( "              END_REPEAT;\n" );
    str.append( "            END_REPEAT;\n" );
    str.append( "            RETURN( TRUE );\n" );
    str.append( "          ELSE\n" );
    str.append( "            IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF( sf ) THEN\n" );
    str.append( "              IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.CONICAL_SURFACE', 'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE', \n" );
    str.append( "                  'CONFIG_CONTROL_DESIGN.PLANE' ] * TYPEOF( sf\\rectangular_trimmed_surface.basis_surface ) ) = 1 THEN\n" );
    str.append( "                RETURN( TRUE );\n" );
    str.append( "              ELSE\n" );
    str.append( "                RETURN( gbsf_check_surface( sf\\rectangular_trimmed_surface.basis_surface ) );\n" );
    str.append( "              END_IF;\n" );
    str.append( "            ELSE\n" );
    str.append( "              IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF( sf ) THEN\n" );
    str.append( "                RETURN( gbsf_check_surface( sf\\surface_replica.parent_surface ) );\n" );
    str.append( "              ELSE\n" );
    str.append( "                IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF( sf ) THEN\n" );
    str.append( "                  RETURN( gbsf_check_curve( sf\\swept_surface.swept_curve ) );\n" );
    str.append( "                END_IF;\n" );
    str.append( "              END_IF;\n" );
    str.append( "            END_IF;\n" );
    str.append( "          END_IF;\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION boolean_choose(\n" );
    str.append( "             b : BOOLEAN;\n" );
    str.append( "             choice1, choice2 : GENERIC:item\n" );
    str.append( "         ) : GENERIC:item;\n" );
    str.append( "  IF b THEN\n" );
    str.append( "    RETURN( choice1 );\n" );
    str.append( "  ELSE\n" );
    str.append( "    RETURN( choice2 );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION msf_surface_check(\n" );
    str.append( "             surf : surface\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF( surf ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF( surf ) THEN\n" );
    str.append( "      RETURN( msf_curve_check( surf\\swept_surface.swept_curve ) );\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF ( ( 'CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF( surf ) ) AND ( surf\\offset_surface.self_intersect = FALSE ) ) OR \n" );
    str.append( "          ( surf\\offset_surface.self_intersect = UNKNOWN ) THEN\n" );
    str.append( "        RETURN( msf_surface_check( surf\\offset_surface.basis_surface ) );\n" );
    str.append( "      ELSE\n" );
    str.append( "        IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF( surf ) THEN\n" );
    str.append( "          RETURN( msf_surface_check( surf\\surface_replica.parent_surface ) );\n" );
    str.append( "        ELSE\n" );
    str.append( "          IF ( ( 'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF( surf ) ) AND ( surf\\b_spline_surface.self_intersect = FALSE ) ) \n" );
    str.append( "              OR ( surf\\b_spline_surface.self_intersect = UNKNOWN ) THEN\n" );
    str.append( "            RETURN( TRUE );\n" );
    str.append( "          END_IF;\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION path_reversed(\n" );
    str.append( "             a_path : path\n" );
    str.append( "         ) : oriented_path;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    the_reverse : oriented_path;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF( a_path ) THEN\n" );
    str.append( "    the_reverse := dummy_tri || path( list_of_topology_reversed( a_path.edge_list ) ) || oriented_path( a_path\\oriented_path.\n" );
    str.append( "        path_element, NOT a_path\\oriented_path.orientation );\n" );
    str.append( "  ELSE\n" );
    str.append( "    the_reverse := dummy_tri || path( list_of_topology_reversed( a_path.edge_list ) ) || oriented_path( a_path, FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( the_reverse );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION valid_measure_value(\n" );
    str.append( "             m : measure_value\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF 'REAL' IN TYPEOF( m ) THEN\n" );
    str.append( "    RETURN( m > 0 );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'INTEGER' IN TYPEOF( m ) THEN\n" );
    str.append( "      RETURN( m > 0 );\n" );
    str.append( "    ELSE\n" );
    str.append( "      RETURN( TRUE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION constraints_composite_curve_on_surface(\n" );
    str.append( "             c : composite_curve_on_surface\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    n_segments : INTEGER := SIZEOF( c.segments );\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT k := 1 TO n_segments BY 1;\n" );
    str.append( "    IF ( NOT ( 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF( c\\composite_curve.segments[k].parent_curve ) ) ) AND ( NOT ( \n" );
    str.append( "        'CONFIG_CONTROL_DESIGN.SURFACE_CURVE'  IN TYPEOF( c\\composite_curve.segments[k].parent_curve ) ) ) AND ( NOT ( \n" );
    str.append( "        'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE'  IN TYPEOF( c\\composite_curve.segments[k].parent_curve ) ) ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION dimension_of(\n" );
    str.append( "             item : geometric_representation_item\n" );
    str.append( "         ) : dimension_count;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    x : SET OF representation;\n" );
    str.append( "    y : representation_context;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  x := using_representations( item );\n" );
    str.append( "  y := x[1].context_of_items;\n" );
    str.append( "  RETURN( y\\geometric_representation_context.coordinate_space_dimension );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION unique_version_change_order(\n" );
    str.append( "             c : action\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    ords     : action_directive := c\\directed_action.directive;\n" );
    str.append( "    assign   : SET OF change_request := [];\n" );
    str.append( "    versions : SET OF product_definition_formation := [];\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT i := 1 TO SIZEOF( ords.requests ) BY 1;\n" );
    str.append( "    assign := assign + QUERY ( ara <* bag_to_set( USEDIN( ords.requests[i], 'CONFIG_CONTROL_DESIGN.ACTION_REQUEST_ASSIGNMENT.' + \n" );
    str.append( "        'ASSIGNED_ACTION_REQUEST'  ) ) | ( 'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' IN TYPEOF( ara ) ) );\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  REPEAT k := 1 TO SIZEOF( assign ) BY 1;\n" );
    str.append( "    versions := versions + assign[k].items;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( SIZEOF( QUERY ( vers <* versions | ( NOT ( SIZEOF( QUERY ( other_vers <* ( versions - vers ) | ( vers.of_product :=: \n" );
    str.append( "      other_vers.of_product ) ) ) = 0 ) ) ) ) = 0 );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION acyclic_point_replica(\n" );
    str.append( "             rep : point_replica;\n" );
    str.append( "             parent : point\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF NOT ( 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF( parent ) ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF parent :=: rep THEN\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    RETURN( acyclic_point_replica( rep, parent\\point_replica.parent_pt ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION cross_product(\n" );
    str.append( "             arg1, arg2 : direction\n" );
    str.append( "         ) : vector;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    v2     : LIST [3 : 3] OF REAL;\n" );
    str.append( "    v1     : LIST [3 : 3] OF REAL;\n" );
    str.append( "    mag    : REAL;\n" );
    str.append( "    res    : direction;\n" );
    str.append( "    result : vector;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF ( NOT EXISTS( arg1 ) ) OR ( arg1.dim = 2 ) OR ( NOT EXISTS( arg2 ) ) OR ( arg2.dim = 2 ) THEN\n" );
    str.append( "    RETURN( ? );\n" );
    str.append( "  ELSE\n" );
    str.append( "    BEGIN\n" );
    str.append( "      v1 := normalise( arg1 ).direction_ratios;\n" );
    str.append( "      v2 := normalise( arg2 ).direction_ratios;\n" );
    str.append( "      res := dummy_gri || direction( [( v1[2] * v2[3] ) - ( v1[3] * v2[2] ), ( v1[3] * v2[1] ) - ( v1[1] * v2[3] ), ( v1[1] * v2[\n" );
    str.append( "          2] ) - ( v1[2] * v2[1] )] );\n" );
    str.append( "      mag := 0;\n" );
    str.append( "      REPEAT i := 1 TO 3 BY 1;\n" );
    str.append( "        mag := mag + ( res.direction_ratios[i] * res.direction_ratios[i] );\n" );
    str.append( "      END_REPEAT;\n" );
    str.append( "      IF mag > 0 THEN\n" );
    str.append( "        result := dummy_gri || vector( res, SQRT( mag ) );\n" );
    str.append( "      ELSE\n" );
    str.append( "        result := dummy_gri || vector( arg1, 0 );\n" );
    str.append( "      END_IF;\n" );
    str.append( "      RETURN( result );\n" );
    str.append( "    END;\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION face_bound_reversed(\n" );
    str.append( "             a_face_bound : face_bound\n" );
    str.append( "         ) : face_bound;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    the_reverse : face_bound;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF( a_face_bound ) THEN\n" );
    str.append( "    the_reverse := dummy_tri || face_bound( a_face_bound\\face_bound.bound, NOT a_face_bound\\face_bound.orientation ) || \n" );
    str.append( "        face_outer_bound(  );\n" );
    str.append( "  ELSE\n" );
    str.append( "    the_reverse := dummy_tri || face_bound( a_face_bound.bound, NOT a_face_bound.orientation );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( the_reverse );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION constraints_geometry_shell_based_surface_model(\n" );
    str.append( "             m : shell_based_surface_model\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    result : BOOLEAN := TRUE;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT j := 1 TO SIZEOF( m.sbsm_boundary ) BY 1;\n" );
    str.append( "    IF ( NOT ( 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF( m.sbsm_boundary[j] ) ) ) AND ( NOT ( 'CONFIG_CONTROL_DESIGN.'\n" );
    str.append( "        + 'CLOSED_SHELL'  IN TYPEOF( m.sbsm_boundary[j] ) ) ) THEN\n" );
    str.append( "      result := FALSE;\n" );
    str.append( "      RETURN( result );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION shell_reversed(\n" );
    str.append( "             a_shell : shell\n" );
    str.append( "         ) : shell;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF( a_shell ) THEN\n" );
    str.append( "    RETURN( open_shell_reversed( a_shell ) );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF( a_shell ) THEN\n" );
    str.append( "      RETURN( closed_shell_reversed( a_shell ) );\n" );
    str.append( "    ELSE\n" );
    str.append( "      RETURN( ? );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION cc_design_date_time_correlation(\n" );
    str.append( "             e : cc_design_date_and_time_assignment\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    dt_role : STRING;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  dt_role := e\\date_and_time_assignment.role.name;\n" );
    str.append( "  CASE dt_role OF\n" );
    str.append( "    'creation_date'      :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'PRODUCT_DEFINITION'  ) IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'request_date'       :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( SIZEOF( [ 'CONFIG_CONTROL_DESIGN.'\n" );
    str.append( "          + 'CHANGE_REQUEST' , 'CONFIG_CONTROL_DESIGN.START_REQUEST'] * TYPEOF( x ) ) = 1 ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'release_date'       :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( SIZEOF( [ 'CONFIG_CONTROL_DESIGN.CHANGE', \n" );
    str.append( "          'CONFIG_CONTROL_DESIGN.START_WORK' ] * TYPEOF( x ) ) = 1 ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'start_date'         :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( SIZEOF( [ 'CONFIG_CONTROL_DESIGN.CHANGE', \n" );
    str.append( "          'CONFIG_CONTROL_DESIGN.START_WORK' ] * TYPEOF( x ) ) = 1 ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'sign_off_date'      :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'APPROVAL_PERSON_ORGANIZATION'  ) IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'contract_date'      :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( 'CONFIG_CONTROL_DESIGN.CONTRACT' IN \n" );
    str.append( "          TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'certification_date' :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( 'CONFIG_CONTROL_DESIGN.CERTIFICATION' \n" );
    str.append( "          IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'classification_date' :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'SECURITY_CLASSIFICATION'  ) IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'declassification_date' :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'SECURITY_CLASSIFICATION'  ) IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    OTHERWISE            :       RETURN( TRUE );\n" );
    str.append( "    END_CASE;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION cc_design_person_and_organization_correlation(\n" );
    str.append( "             e : cc_design_person_and_organization_assignment\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    po_role : STRING;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  po_role := e\\person_and_organization_assignment.role.name;\n" );
    str.append( "  CASE po_role OF\n" );
    str.append( "    'request_recipient'   :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( SIZEOF( [ 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'CHANGE_REQUEST' , 'CONFIG_CONTROL_DESIGN.' + 'START_REQUEST'] * TYPEOF( x ) ) = 1 ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'initiator'           :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( SIZEOF( [ 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'CHANGE_REQUEST' , 'CONFIG_CONTROL_DESIGN.' + 'START_REQUEST', 'CONFIG_CONTROL_DESIGN.' + 'START_WORK', \n" );
    str.append( "          'CONFIG_CONTROL_DESIGN.'  + 'CHANGE'] * TYPEOF( x ) ) = 1 ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'creator'             :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( SIZEOF( [ 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'PRODUCT_DEFINITION_FORMATION' , 'CONFIG_CONTROL_DESIGN.' + 'PRODUCT_DEFINITION'] * TYPEOF( x ) ) = 1 ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'part_supplier'       :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'PRODUCT_DEFINITION_FORMATION'  ) IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'design_supplier'     :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'PRODUCT_DEFINITION_FORMATION'  ) IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'design_owner'        :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( 'CONFIG_CONTROL_DESIGN.PRODUCT' IN \n" );
    str.append( "          TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'configuration_manager' :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'CONFIGURATION_ITEM'  ) IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'contractor'          :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( 'CONFIG_CONTROL_DESIGN.CONTRACT' IN \n" );
    str.append( "          TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    'classification_officer' :       IF SIZEOF( e.items ) <> SIZEOF( QUERY ( x <* e.items | ( ( 'CONFIG_CONTROL_DESIGN.' + \n" );
    str.append( "          'SECURITY_CLASSIFICATION'  ) IN TYPEOF( x ) ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    OTHERWISE             :       RETURN( TRUE );\n" );
    str.append( "    END_CASE;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION get_basis_surface(\n" );
    str.append( "             c : curve_on_surface\n" );
    str.append( "         ) : SET [0 : 2] OF surface;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    surfs : SET [0 : 2] OF surface;\n" );
    str.append( "    n     : INTEGER;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  surfs := [];\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF( c ) THEN\n" );
    str.append( "    surfs := [c\\pcurve.basis_surface];\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF( c ) THEN\n" );
    str.append( "      n := SIZEOF( c\\surface_curve.associated_geometry );\n" );
    str.append( "      REPEAT i := 1 TO n BY 1;\n" );
    str.append( "        surfs := surfs + associated_surface( c\\surface_curve.associated_geometry[i] );\n" );
    str.append( "      END_REPEAT;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF( c ) THEN\n" );
    str.append( "    n := SIZEOF( c\\composite_curve.segments );\n" );
    str.append( "    surfs := get_basis_surface( c\\composite_curve.segments[1].parent_curve );\n" );
    str.append( "    IF n > 1 THEN\n" );
    str.append( "      REPEAT i := 2 TO n BY 1;\n" );
    str.append( "        surfs := surfs * get_basis_surface( c\\composite_curve.segments[i].parent_curve );\n" );
    str.append( "      END_REPEAT;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( surfs );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION dot_product(\n" );
    str.append( "             arg1, arg2 : direction\n" );
    str.append( "         ) : REAL;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    ndim   : INTEGER;\n" );
    str.append( "    scalar : REAL;\n" );
    str.append( "    vec1   : direction;\n" );
    str.append( "    vec2   : direction;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF ( NOT EXISTS( arg1 ) ) OR ( NOT EXISTS( arg2 ) ) THEN\n" );
    str.append( "    scalar := ?;\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF arg1.dim <> arg2.dim THEN\n" );
    str.append( "      scalar := ?;\n" );
    str.append( "    ELSE\n" );
    str.append( "      BEGIN\n" );
    str.append( "        vec1 := normalise( arg1 );\n" );
    str.append( "        vec2 := normalise( arg2 );\n" );
    str.append( "        ndim := arg1.dim;\n" );
    str.append( "        scalar := 0;\n" );
    str.append( "        REPEAT i := 1 TO ndim BY 1;\n" );
    str.append( "          scalar := scalar + ( vec1.direction_ratios[i] * vec2.direction_ratios[i] );\n" );
    str.append( "        END_REPEAT;\n" );
    str.append( "      END;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( scalar );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION list_of_topology_reversed(\n" );
    str.append( "             a_list : list_of_reversible_topology_item\n" );
    str.append( "         ) : list_of_reversible_topology_item;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    the_reverse : list_of_reversible_topology_item;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  the_reverse := [];\n" );
    str.append( "  REPEAT i := 1 TO SIZEOF( a_list ) BY 1;\n" );
    str.append( "    the_reverse := topology_reversed( a_list[i] ) + the_reverse;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( the_reverse );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION acyclic_mapped_representation(\n" );
    str.append( "             parent_set : SET OF representation;\n" );
    str.append( "             children_set : SET OF representation_item\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    i : INTEGER;\n" );
    str.append( "    x : SET OF representation_item;\n" );
    str.append( "    y : SET OF representation_item;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  x := QUERY ( z <* children_set | ( 'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF( z ) ) );\n" );
    str.append( "  IF SIZEOF( x ) > 0 THEN\n" );
    str.append( "    REPEAT i := 1 TO HIINDEX( x ) BY 1;\n" );
    str.append( "      IF x[i]\\mapped_item.mapping_source.mapped_representation IN parent_set THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "      IF NOT acyclic_mapped_representation( parent_set + x[i]\\mapped_item.mapping_source.mapped_representation, x[i]\\mapped_item.\n" );
    str.append( "          mapping_source.mapped_representation.items ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  x := children_set - x;\n" );
    str.append( "  IF SIZEOF( x ) > 0 THEN\n" );
    str.append( "    REPEAT i := 1 TO HIINDEX( x ) BY 1;\n" );
    str.append( "      y := QUERY ( z <* bag_to_set( USEDIN( x[i], '' ) ) | ( 'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF( z ) ) );\n" );
    str.append( "      IF NOT acyclic_mapped_representation( parent_set, y ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION base_axis(\n" );
    str.append( "             dim : INTEGER;\n" );
    str.append( "             axis1, axis2, axis3 : direction\n" );
    str.append( "         ) : LIST [2 : 3] OF direction;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    u      : LIST [2 : 3] OF direction;\n" );
    str.append( "    d1     : direction;\n" );
    str.append( "    d2     : direction;\n" );
    str.append( "    factor : REAL;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF dim = 3 THEN\n" );
    str.append( "    d1 := NVL( normalise( axis3 ), dummy_gri || direction( [0, 0, 1] ) );\n" );
    str.append( "    d2 := first_proj_axis( d1, axis1 );\n" );
    str.append( "    u := [d2, second_proj_axis( d1, d2, axis2 ), d1];\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF EXISTS( axis1 ) THEN\n" );
    str.append( "      d1 := normalise( axis1 );\n" );
    str.append( "      u := [d1, orthogonal_complement( d1 )];\n" );
    str.append( "      IF EXISTS( axis2 ) THEN\n" );
    str.append( "        factor := dot_product( axis2, u[2] );\n" );
    str.append( "        IF factor < 0 THEN\n" );
    str.append( "          u[2].direction_ratios[1] := -u[2].direction_ratios[1];\n" );
    str.append( "          u[2].direction_ratios[2] := -u[2].direction_ratios[2];\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF EXISTS( axis2 ) THEN\n" );
    str.append( "        d1 := normalise( axis2 );\n" );
    str.append( "        u := [orthogonal_complement( d1 ), d1];\n" );
    str.append( "        u[1].direction_ratios[1] := -u[1].direction_ratios[1];\n" );
    str.append( "        u[1].direction_ratios[2] := -u[1].direction_ratios[2];\n" );
    str.append( "      ELSE\n" );
    str.append( "        u := [dummy_gri || direction( [1, 0] ), dummy_gri || direction( [0, 1] )];\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( u );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION acyclic_curve_replica(\n" );
    str.append( "             rep : curve_replica;\n" );
    str.append( "             parent : curve\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF NOT ( 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF( parent ) ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF parent :=: rep THEN\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    RETURN( acyclic_curve_replica( rep, parent\\curve_replica.parent_curve ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION face_reversed(\n" );
    str.append( "             a_face : face\n" );
    str.append( "         ) : oriented_face;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    the_reverse : oriented_face;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF( a_face ) THEN\n" );
    str.append( "    the_reverse := dummy_tri || face( set_of_topology_reversed( a_face.bounds ) ) || oriented_face( a_face\\oriented_face.\n" );
    str.append( "        face_element, NOT a_face\\oriented_face.orientation );\n" );
    str.append( "  ELSE\n" );
    str.append( "    the_reverse := dummy_tri || face( set_of_topology_reversed( a_face.bounds ) ) || oriented_face( a_face, FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( the_reverse );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION edge_reversed(\n" );
    str.append( "             an_edge : edge\n" );
    str.append( "         ) : oriented_edge;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    the_reverse : oriented_edge;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF( an_edge ) THEN\n" );
    str.append( "    the_reverse := dummy_tri || edge( an_edge.edge_end, an_edge.edge_start ) || oriented_edge( an_edge\\oriented_edge.edge_element, \n" );
    str.append( "        NOT an_edge\\oriented_edge.orientation );\n" );
    str.append( "  ELSE\n" );
    str.append( "    the_reverse := dummy_tri || edge( an_edge.edge_end, an_edge.edge_start ) || oriented_edge( an_edge, FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( the_reverse );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION list_to_set(\n" );
    str.append( "             l : LIST [0 : ?] OF GENERIC:t\n" );
    str.append( "         ) : SET OF GENERIC:t;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    s : SET OF GENERIC:t := [];\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT i := 1 TO SIZEOF( l ) BY 1;\n" );
    str.append( "    s := s + l[i];\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( s );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION constraints_param_b_spline(\n" );
    str.append( "             degree, up_knots, up_cp : INTEGER;\n" );
    str.append( "             knot_mult : LIST OF INTEGER;\n" );
    str.append( "             knots : LIST OF parameter_value\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    k      : INTEGER;\n" );
    str.append( "    sum    : INTEGER;\n" );
    str.append( "    result : BOOLEAN := TRUE;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  sum := knot_mult[1];\n" );
    str.append( "  REPEAT i := 2 TO up_knots BY 1;\n" );
    str.append( "    sum := sum + knot_mult[i];\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  IF ( degree < 1 ) OR ( up_knots < 2 ) OR ( up_cp < degree ) OR ( sum <> ( degree + up_cp + 2 ) ) THEN\n" );
    str.append( "    result := FALSE;\n" );
    str.append( "    RETURN( result );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  k := knot_mult[1];\n" );
    str.append( "  IF ( k < 1 ) OR ( k > ( degree + 1 ) ) THEN\n" );
    str.append( "    result := FALSE;\n" );
    str.append( "    RETURN( result );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  REPEAT i := 2 TO up_knots BY 1;\n" );
    str.append( "    IF ( knot_mult[i] < 1 ) OR ( knots[i] <= knots[i - 1] ) THEN\n" );
    str.append( "      result := FALSE;\n" );
    str.append( "      RETURN( result );\n" );
    str.append( "    END_IF;\n" );
    str.append( "    k := knot_mult[i];\n" );
    str.append( "    IF ( i < up_knots ) AND ( k > degree ) THEN\n" );
    str.append( "      result := FALSE;\n" );
    str.append( "      RETURN( result );\n" );
    str.append( "    END_IF;\n" );
    str.append( "    IF ( i = up_knots ) AND ( k > ( degree + 1 ) ) THEN\n" );
    str.append( "      result := FALSE;\n" );
    str.append( "      RETURN( result );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION item_in_context(\n" );
    str.append( "             item : representation_item;\n" );
    str.append( "             cntxt : representation_context\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    i : INTEGER;\n" );
    str.append( "    y : BAG OF representation_item;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF SIZEOF( USEDIN( item, 'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS' ) * cntxt.representations_in_context ) > 0 THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    y := QUERY ( z <* USEDIN( item, '' ) | ( 'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF( z ) ) );\n" );
    str.append( "    IF SIZEOF( y ) > 0 THEN\n" );
    str.append( "      REPEAT i := 1 TO HIINDEX( y ) BY 1;\n" );
    str.append( "        IF item_in_context( y[i], cntxt ) THEN\n" );
    str.append( "          RETURN( TRUE );\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END_REPEAT;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION valid_units(\n" );
    str.append( "             m : measure_with_unit\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.LENGTH_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 1, 0, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.MASS_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 1, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.TIME_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 1, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 0, 1, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 0, 0, 1, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 0, 0, 0, 1, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 0, 0, 0, 0, 1 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.AREA_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 2, 0, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.VOLUME_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 3, 0, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.RATIO_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 1, 0, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF( m.value_component ) THEN\n" );
    str.append( "    IF derive_dimensional_exponents( m.unit_component ) <> dimensional_exponents( 0, 0, 0, 0, 0, 0, 0 ) THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION acyclic_product_category_relationship(\n" );
    str.append( "             relation : product_category_relationship;\n" );
    str.append( "             children : SET OF product_category\n" );
    str.append( "         ) : LOGICAL;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    i              : INTEGER;\n" );
    str.append( "    x              : SET OF product_category_relationship;\n" );
    str.append( "    local_children : SET OF product_category;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT i := 1 TO HIINDEX( children ) BY 1;\n" );
    str.append( "    IF relation.category :=: children[i] THEN\n" );
    str.append( "      RETURN( FALSE );\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  x := bag_to_set( USEDIN( relation.category, 'CONFIG_CONTROL_DESIGN.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY' ) );\n" );
    str.append( "  local_children := children + relation.category;\n" );
    str.append( "  IF SIZEOF( x ) > 0 THEN\n" );
    str.append( "    REPEAT i := 1 TO HIINDEX( x ) BY 1;\n" );
    str.append( "      IF NOT acyclic_product_category_relationship( x[i], local_children ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION assembly_shape_is_defined(\n" );
    str.append( "             assy : next_assembly_usage_occurrence;\n" );
    str.append( "             schma : STRING\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    srr_set   : SET OF shape_representation_relationship := [];\n" );
    str.append( "    i         : INTEGER;\n" );
    str.append( "    j         : INTEGER;\n" );
    str.append( "    sdr_set   : SET OF shape_definition_representation := [];\n" );
    str.append( "    pr1_set   : SET OF property_definition := [];\n" );
    str.append( "    pdrel_set : SET OF product_definition_relationship := [];\n" );
    str.append( "    pr2_set   : SET OF property_definition := [];\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  pr1_set := bag_to_set( USEDIN( assy.related_product_definition, schma + '.PROPERTY_DEFINITION.DEFINITION' ) );\n" );
    str.append( "  REPEAT i := 1 TO HIINDEX( pr1_set ) BY 1;\n" );
    str.append( "    sdr_set := sdr_set + QUERY ( pdr <* USEDIN( pr1_set[i], schma + '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | ( ( \n" );
    str.append( "        schma + '.SHAPE_DEFINITION_REPRESENTATION' ) IN TYPEOF( pdr ) ) );\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  pdrel_set := bag_to_set( USEDIN( assy.related_product_definition, schma + '.PRODUCT_DEFINITION_RELATIONSHIP.' + \n" );
    str.append( "      'RELATED_PRODUCT_DEFINITION'  ) );\n" );
    str.append( "  REPEAT j := 1 TO HIINDEX( pdrel_set ) BY 1;\n" );
    str.append( "    pr2_set := pr2_set + USEDIN( pdrel_set[j], schma + '.PROPERTY_DEFINITION.DEFINITION' );\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  REPEAT i := 1 TO HIINDEX( pr2_set ) BY 1;\n" );
    str.append( "    sdr_set := sdr_set + QUERY ( pdr <* USEDIN( pr2_set[i], schma + '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | ( ( \n" );
    str.append( "        schma + '.SHAPE_DEFINITION_REPRESENTATION' ) IN TYPEOF( pdr ) ) );\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  IF SIZEOF( sdr_set ) > 0 THEN\n" );
    str.append( "    REPEAT i := 1 TO HIINDEX( sdr_set ) BY 1;\n" );
    str.append( "      srr_set := QUERY ( rr <* bag_to_set( USEDIN( sdr_set[i]\\property_definition_representation.used_representation, schma + '.'\n" );
    str.append( "          + 'REPRESENTATION_RELATIONSHIP.REP_2'  ) ) | ( ( schma + '.SHAPE_REPRESENTATION_RELATIONSHIP' ) IN TYPEOF( rr ) ) );\n" );
    str.append( "      IF SIZEOF( srr_set ) > 0 THEN\n" );
    str.append( "        REPEAT j := 1 TO HIINDEX( srr_set ) BY 1;\n" );
    str.append( "          IF SIZEOF( QUERY ( pdr <* bag_to_set( USEDIN( srr_set[j]\\representation_relationship.rep_1, schma + '.'\n" );
    str.append( "              + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'  ) ) | ( ( schma + '.SHAPE_DEFINITION_REPRESENTATION' ) \n" );
    str.append( "              IN TYPEOF( pdr ) ) ) * QUERY ( pdr <* bag_to_set( USEDIN( assy.relating_product_definition, schma + '.'\n" );
    str.append( "              + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'  ) ) | ( ( schma + '.SHAPE_DEFINITION_REPRESENTATION' ) IN \n" );
    str.append( "              TYPEOF( pdr ) ) ) ) >= 1 THEN\n" );
    str.append( "            IF SIZEOF( QUERY ( cdsr <* USEDIN( srr_set[j], schma + '.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' + \n" );
    str.append( "                'REPRESENTATION_RELATION'  ) | ( NOT ( cdsr\\context_dependent_shape_representation.represented_product_relation\\\n" );
    str.append( "                property_definition.definition :=: assy ) ) ) ) > 0 THEN\n" );
    str.append( "              RETURN( FALSE );\n" );
    str.append( "            END_IF;\n" );
    str.append( "          END_IF;\n" );
    str.append( "        END_REPEAT;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION first_proj_axis(\n" );
    str.append( "             z_axis, arg : direction\n" );
    str.append( "         ) : direction;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    x_vec  : vector;\n" );
    str.append( "    v      : direction;\n" );
    str.append( "    z      : direction;\n" );
    str.append( "    x_axis : direction;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF NOT EXISTS( z_axis ) THEN\n" );
    str.append( "    RETURN( ? );\n" );
    str.append( "  ELSE\n" );
    str.append( "    z := normalise( z_axis );\n" );
    str.append( "    IF NOT EXISTS( arg ) THEN\n" );
    str.append( "      IF z.direction_ratios <> [1, 0, 0] THEN\n" );
    str.append( "        v := dummy_gri || direction( [1, 0, 0] );\n" );
    str.append( "      ELSE\n" );
    str.append( "        v := dummy_gri || direction( [0, 1, 0] );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF arg.dim <> 3 THEN\n" );
    str.append( "        RETURN( ? );\n" );
    str.append( "      END_IF;\n" );
    str.append( "      IF cross_product( arg, z ).magnitude = 0 THEN\n" );
    str.append( "        RETURN( ? );\n" );
    str.append( "      ELSE\n" );
    str.append( "        v := normalise( arg );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "    x_vec := scalar_times_vector( dot_product( v, z ), z );\n" );
    str.append( "    x_axis := vector_difference( v, x_vec ).orientation;\n" );
    str.append( "    x_axis := normalise( x_axis );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( x_axis );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION surface_weights_positive(\n" );
    str.append( "             b : rational_b_spline_surface\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    result : BOOLEAN := TRUE;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  REPEAT i := 0 TO b.u_upper BY 1;\n" );
    str.append( "    REPEAT j := 0 TO b.v_upper BY 1;\n" );
    str.append( "      IF b.weights[i][j] <= 0 THEN\n" );
    str.append( "        result := FALSE;\n" );
    str.append( "        RETURN( result );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION conditional_reverse(\n" );
    str.append( "             p : BOOLEAN;\n" );
    str.append( "             an_item : reversible_topology\n" );
    str.append( "         ) : reversible_topology;\n" );
    str.append( "  IF p THEN\n" );
    str.append( "    RETURN( an_item );\n" );
    str.append( "  ELSE\n" );
    str.append( "    RETURN( topology_reversed( an_item ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION dimensions_for_si_unit(\n" );
    str.append( "             n : si_unit_name\n" );
    str.append( "         ) : dimensional_exponents;\n" );
    str.append( "  CASE n OF\n" );
    str.append( "    metre         :       RETURN( dimensional_exponents( 1, 0, 0, 0, 0, 0, 0 ) );\n" );
    str.append( "    gram          :       RETURN( dimensional_exponents( 0, 1, 0, 0, 0, 0, 0 ) );\n" );
    str.append( "    second        :       RETURN( dimensional_exponents( 0, 0, 1, 0, 0, 0, 0 ) );\n" );
    str.append( "    ampere        :       RETURN( dimensional_exponents( 0, 0, 0, 1, 0, 0, 0 ) );\n" );
    str.append( "    kelvin        :       RETURN( dimensional_exponents( 0, 0, 0, 0, 1, 0, 0 ) );\n" );
    str.append( "    mole          :       RETURN( dimensional_exponents( 0, 0, 0, 0, 0, 1, 0 ) );\n" );
    str.append( "    candela       :       RETURN( dimensional_exponents( 0, 0, 0, 0, 0, 0, 1 ) );\n" );
    str.append( "    radian        :       RETURN( dimensional_exponents( 0, 0, 0, 0, 0, 0, 0 ) );\n" );
    str.append( "    steradian     :       RETURN( dimensional_exponents( 0, 0, 0, 0, 0, 0, 0 ) );\n" );
    str.append( "    hertz         :       RETURN( dimensional_exponents( 0, 0, -1, 0, 0, 0, 0 ) );\n" );
    str.append( "    newton        :       RETURN( dimensional_exponents( 1, 1, -2, 0, 0, 0, 0 ) );\n" );
    str.append( "    pascal        :       RETURN( dimensional_exponents( -1, 1, -2, 0, 0, 0, 0 ) );\n" );
    str.append( "    joule         :       RETURN( dimensional_exponents( 2, 1, -2, 0, 0, 0, 0 ) );\n" );
    str.append( "    watt          :       RETURN( dimensional_exponents( 2, 1, -3, 0, 0, 0, 0 ) );\n" );
    str.append( "    coulomb       :       RETURN( dimensional_exponents( 0, 0, 1, 1, 0, 0, 0 ) );\n" );
    str.append( "    volt          :       RETURN( dimensional_exponents( 2, 1, -3, -1, 0, 0, 0 ) );\n" );
    str.append( "    farad         :       RETURN( dimensional_exponents( -2, -1, 4, 1, 0, 0, 0 ) );\n" );
    str.append( "    ohm           :       RETURN( dimensional_exponents( 2, 1, -3, -2, 0, 0, 0 ) );\n" );
    str.append( "    siemens       :       RETURN( dimensional_exponents( -2, -1, 3, 2, 0, 0, 0 ) );\n" );
    str.append( "    weber         :       RETURN( dimensional_exponents( 2, 1, -2, -1, 0, 0, 0 ) );\n" );
    str.append( "    tesla         :       RETURN( dimensional_exponents( 0, 1, -2, -1, 0, 0, 0 ) );\n" );
    str.append( "    henry         :       RETURN( dimensional_exponents( 2, 1, -2, -2, 0, 0, 0 ) );\n" );
    str.append( "    degree_celsius :       RETURN( dimensional_exponents( 0, 0, 0, 0, 1, 0, 0 ) );\n" );
    str.append( "    lumen         :       RETURN( dimensional_exponents( 0, 0, 0, 0, 0, 0, 1 ) );\n" );
    str.append( "    lux           :       RETURN( dimensional_exponents( -2, 0, 0, 0, 0, 0, 1 ) );\n" );
    str.append( "    becquerel     :       RETURN( dimensional_exponents( 0, 0, -1, 0, 0, 0, 0 ) );\n" );
    str.append( "    gray          :       RETURN( dimensional_exponents( 2, 0, -2, 0, 0, 0, 0 ) );\n" );
    str.append( "    sievert       :       RETURN( dimensional_exponents( 2, 0, -2, 0, 0, 0, 0 ) );\n" );
    str.append( "    END_CASE;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION open_shell_reversed(\n" );
    str.append( "             a_shell : open_shell\n" );
    str.append( "         ) : oriented_open_shell;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    the_reverse : oriented_open_shell;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF( a_shell ) THEN\n" );
    str.append( "    the_reverse := dummy_tri || connected_face_set( a_shell\\connected_face_set.cfs_faces ) || open_shell(  ) || \n" );
    str.append( "        oriented_open_shell( a_shell\\oriented_open_shell.open_shell_element, NOT a_shell\\oriented_open_shell.orientation );\n" );
    str.append( "  ELSE\n" );
    str.append( "    the_reverse := dummy_tri || connected_face_set( a_shell\\connected_face_set.cfs_faces ) || open_shell(  ) || \n" );
    str.append( "        oriented_open_shell( a_shell, FALSE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( the_reverse );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION valid_geometrically_bounded_wf_point(\n" );
    str.append( "             pnt : point\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF( pnt ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF( pnt ) THEN\n" );
    str.append( "      RETURN( valid_geometrically_bounded_wf_curve( pnt\\point_on_curve.basis_curve ) );\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF( pnt ) THEN\n" );
    str.append( "        RETURN( valid_geometrically_bounded_wf_point( pnt\\point_replica.parent_pt ) );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION associated_surface(\n" );
    str.append( "             arg : pcurve_or_surface\n" );
    str.append( "         ) : surface;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    surf : surface;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF( arg ) THEN\n" );
    str.append( "    surf := arg.basis_surface;\n" );
    str.append( "  ELSE\n" );
    str.append( "    surf := arg;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( surf );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION constraints_rectangular_composite_surface(\n" );
    str.append( "             s : rectangular_composite_surface\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  REPEAT i := 1 TO s.n_u BY 1;\n" );
    str.append( "    REPEAT j := 1 TO s.n_v BY 1;\n" );
    str.append( "      IF NOT ( ( 'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF( s.segments[i][j].parent_surface ) ) OR ( \n" );
    str.append( "          'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE'  IN TYPEOF( s.segments[i][j].parent_surface ) ) ) THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  REPEAT i := 1 TO s.n_u - 1 BY 1;\n" );
    str.append( "    REPEAT j := 1 TO s.n_v BY 1;\n" );
    str.append( "      IF s.segments[i][j].u_transition = discontinuous THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  REPEAT i := 1 TO s.n_u BY 1;\n" );
    str.append( "    REPEAT j := 1 TO s.n_v - 1 BY 1;\n" );
    str.append( "      IF s.segments[i][j].v_transition = discontinuous THEN\n" );
    str.append( "        RETURN( FALSE );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_REPEAT;\n" );
    str.append( "  RETURN( TRUE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION vector_difference(\n" );
    str.append( "             arg1, arg2 : vector_or_direction\n" );
    str.append( "         ) : vector;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    ndim   : INTEGER;\n" );
    str.append( "    mag2   : REAL;\n" );
    str.append( "    mag1   : REAL;\n" );
    str.append( "    mag    : REAL;\n" );
    str.append( "    res    : direction;\n" );
    str.append( "    vec1   : direction;\n" );
    str.append( "    vec2   : direction;\n" );
    str.append( "    result : vector;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  IF ( NOT EXISTS( arg1 ) ) OR ( NOT EXISTS( arg2 ) ) OR ( arg1.dim <> arg2.dim ) THEN\n" );
    str.append( "    RETURN( ? );\n" );
    str.append( "  ELSE\n" );
    str.append( "    BEGIN\n" );
    str.append( "      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF( arg1 ) THEN\n" );
    str.append( "        mag1 := arg1.magnitude;\n" );
    str.append( "        vec1 := arg1.orientation;\n" );
    str.append( "      ELSE\n" );
    str.append( "        mag1 := 1;\n" );
    str.append( "        vec1 := arg1;\n" );
    str.append( "      END_IF;\n" );
    str.append( "      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF( arg2 ) THEN\n" );
    str.append( "        mag2 := arg2.magnitude;\n" );
    str.append( "        vec2 := arg2.orientation;\n" );
    str.append( "      ELSE\n" );
    str.append( "        mag2 := 1;\n" );
    str.append( "        vec2 := arg2;\n" );
    str.append( "      END_IF;\n" );
    str.append( "      vec1 := normalise( vec1 );\n" );
    str.append( "      vec2 := normalise( vec2 );\n" );
    str.append( "      ndim := SIZEOF( vec1.direction_ratios );\n" );
    str.append( "      mag := 0;\n" );
    str.append( "      res := dummy_gri || direction( vec1.direction_ratios );\n" );
    str.append( "      REPEAT i := 1 TO ndim BY 1;\n" );
    str.append( "        res.direction_ratios[i] := ( mag1 * vec1.direction_ratios[i] ) + ( mag2 * vec2.direction_ratios[i] );\n" );
    str.append( "        mag := mag + ( res.direction_ratios[i] * res.direction_ratios[i] );\n" );
    str.append( "      END_REPEAT;\n" );
    str.append( "      IF mag > 0 THEN\n" );
    str.append( "        result := dummy_gri || vector( res, SQRT( mag ) );\n" );
    str.append( "      ELSE\n" );
    str.append( "        result := dummy_gri || vector( vec1, 0 );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( result );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION acyclic_surface_replica(\n" );
    str.append( "             rep : surface_replica;\n" );
    str.append( "             parent : surface\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF NOT ( 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF( parent ) ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF parent :=: rep THEN\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    RETURN( acyclic_surface_replica( rep, parent\\surface_replica.parent_surface ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION list_to_array(\n" );
    str.append( "             lis : LIST [0 : ?] OF GENERIC:t;\n" );
    str.append( "             low, u : INTEGER\n" );
    str.append( "         ) : ARRAY OF GENERIC:t;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    n   : INTEGER;\n" );
    str.append( "    res : ARRAY [low : u] OF GENERIC:t;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  n := SIZEOF( lis );\n" );
    str.append( "  IF n <> ( ( u - low ) + 1 ) THEN\n" );
    str.append( "    RETURN( ? );\n" );
    str.append( "  ELSE\n" );
    str.append( "    res := [lis[1], n];\n" );
    str.append( "    REPEAT i := 2 TO n BY 1;\n" );
    str.append( "      res[( low + i ) - 1] := lis[i];\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "    RETURN( res );\n" );
    str.append( "  END_IF;\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION msf_curve_check(\n" );
    str.append( "             cv : curve\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.BOUNDED_CURVE', 'CONFIG_CONTROL_DESIGN.CONIC', 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA', \n" );
    str.append( "      'CONFIG_CONTROL_DESIGN.LINE' , 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] * TYPEOF( cv ) ) > 1 THEN\n" );
    str.append( "    RETURN( FALSE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF ( ( 'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF( cv ) ) AND ( cv\\b_spline_curve.self_intersect = FALSE ) ) OR ( cv\\\n" );
    str.append( "        b_spline_curve.self_intersect = UNKNOWN ) THEN\n" );
    str.append( "      RETURN( TRUE );\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF SIZEOF( [ 'CONFIG_CONTROL_DESIGN.CONIC', 'CONFIG_CONTROL_DESIGN.LINE'] * TYPEOF( cv ) ) = 1 THEN\n" );
    str.append( "        RETURN( TRUE );\n" );
    str.append( "      ELSE\n" );
    str.append( "        IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF( cv ) THEN\n" );
    str.append( "          RETURN( msf_curve_check( cv\\curve_replica.parent_curve ) );\n" );
    str.append( "        ELSE\n" );
    str.append( "          IF ( 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF( cv ) ) AND ( ( cv\\offset_curve_3d.self_intersect = FALSE ) OR \n" );
    str.append( "              ( cv\\offset_curve_3d.self_intersect = UNKNOWN ) ) AND ( NOT ( 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF( cv.\n" );
    str.append( "              basis_curve ) ) ) THEN\n" );
    str.append( "            RETURN( msf_curve_check( cv\\offset_curve_3d.basis_curve ) );\n" );
    str.append( "          ELSE\n" );
    str.append( "            IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF( cv ) THEN\n" );
    str.append( "              RETURN( msf_curve_check( cv\\pcurve.reference_to_curve\\representation.items[1] ) AND msf_surface_check( cv\\pcurve.\n" );
    str.append( "                  basis_surface ) );\n" );
    str.append( "            ELSE\n" );
    str.append( "              IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF( cv ) THEN\n" );
    str.append( "                IF msf_curve_check( cv\\surface_curve.curve_3d ) THEN\n" );
    str.append( "                  REPEAT i := 1 TO SIZEOF( cv\\surface_curve.associated_geometry ) BY 1;\n" );
    str.append( "                    IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF( cv\\surface_curve.associated_geometry[i] ) THEN\n" );
    str.append( "                      IF NOT msf_surface_check( cv\\surface_curve.associated_geometry[i] ) THEN\n" );
    str.append( "                        RETURN( FALSE );\n" );
    str.append( "                      END_IF;\n" );
    str.append( "                    ELSE\n" );
    str.append( "                      IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF( cv\\surface_curve.associated_geometry[i] ) THEN\n" );
    str.append( "                        IF NOT msf_curve_check( cv\\surface_curve.associated_geometry[i] ) THEN\n" );
    str.append( "                          RETURN( FALSE );\n" );
    str.append( "                        END_IF;\n" );
    str.append( "                      END_IF;\n" );
    str.append( "                    END_IF;\n" );
    str.append( "                  END_REPEAT;\n" );
    str.append( "                  RETURN( TRUE );\n" );
    str.append( "                END_IF;\n" );
    str.append( "              ELSE\n" );
    str.append( "                IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF( cv ) THEN\n" );
    str.append( "                  IF SIZEOF( cv\\polyline.points ) >= 3 THEN\n" );
    str.append( "                    RETURN( TRUE );\n" );
    str.append( "                  END_IF;\n" );
    str.append( "                END_IF;\n" );
    str.append( "              END_IF;\n" );
    str.append( "            END_IF;\n" );
    str.append( "          END_IF;\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION using_items(\n" );
    str.append( "             item : founded_item_select;\n" );
    str.append( "             checked_items : SET OF founded_item_select\n" );
    str.append( "         ) : SET OF founded_item_select;\n" );
    str.append( "  LOCAL\n" );
    str.append( "    next_items      : SET OF founded_item_select;\n" );
    str.append( "    new_check_items : SET OF founded_item_select;\n" );
    str.append( "    result_items    : SET OF founded_item_select;\n" );
    str.append( "  END_LOCAL;\n" );
    str.append( "  result_items := [];\n" );
    str.append( "  new_check_items := checked_items + item;\n" );
    str.append( "  next_items := QUERY ( z <* bag_to_set( USEDIN( item, '' ) ) | ( ( 'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF( z ) ) \n" );
    str.append( "      OR ( 'CONFIG_CONTROL_DESIGN.FOUNDED_ITEM' IN TYPEOF( z ) ) ) );\n" );
    str.append( "  IF SIZEOF( next_items ) > 0 THEN\n" );
    str.append( "    REPEAT i := 1 TO HIINDEX( next_items ) BY 1;\n" );
    str.append( "      IF NOT ( next_items[i] IN new_check_items ) THEN\n" );
    str.append( "        result_items := result_items + next_items[i] + using_items( next_items[i], new_check_items );\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_REPEAT;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( result_items );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION gbsf_check_point(\n" );
    str.append( "             pnt : point\n" );
    str.append( "         ) : BOOLEAN;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF( pnt ) THEN\n" );
    str.append( "    RETURN( TRUE );\n" );
    str.append( "  ELSE\n" );
    str.append( "    IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF( pnt ) THEN\n" );
    str.append( "      RETURN( gbsf_check_curve( pnt\\point_on_curve.basis_curve ) );\n" );
    str.append( "    ELSE\n" );
    str.append( "      IF 'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE' IN TYPEOF( pnt ) THEN\n" );
    str.append( "        RETURN( gbsf_check_surface( pnt\\point_on_surface.basis_surface ) );\n" );
    str.append( "      ELSE\n" );
    str.append( "        IF 'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE' IN TYPEOF( pnt ) THEN\n" );
    str.append( "          RETURN( gbsf_check_curve( pnt\\degenerate_pcurve.reference_to_curve\\representation.items[1] ) AND gbsf_check_surface( \n" );
    str.append( "              pnt\\degenerate_pcurve.basis_surface ) );\n" );
    str.append( "        END_IF;\n" );
    str.append( "      END_IF;\n" );
    str.append( "    END_IF;\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( FALSE );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );
    str.clear();
    str.append( "FUNCTION topology_reversed(\n" );
    str.append( "             an_item : reversible_topology\n" );
    str.append( "         ) : reversible_topology;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.EDGE' IN TYPEOF( an_item ) THEN\n" );
    str.append( "    RETURN( edge_reversed( an_item ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.PATH' IN TYPEOF( an_item ) THEN\n" );
    str.append( "    RETURN( path_reversed( an_item ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.FACE_BOUND' IN TYPEOF( an_item ) THEN\n" );
    str.append( "    RETURN( face_bound_reversed( an_item ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.FACE' IN TYPEOF( an_item ) THEN\n" );
    str.append( "    RETURN( face_reversed( an_item ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'CONFIG_CONTROL_DESIGN.SHELL' IN TYPEOF( an_item ) THEN\n" );
    str.append( "    RETURN( shell_reversed( an_item ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'SET' IN TYPEOF( an_item ) THEN\n" );
    str.append( "    RETURN( set_of_topology_reversed( an_item ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  IF 'LIST' IN TYPEOF( an_item ) THEN\n" );
    str.append( "    RETURN( list_of_topology_reversed( an_item ) );\n" );
    str.append( "  END_IF;\n" );
    str.append( "  RETURN( ? );\n" );
    str.append( "END_FUNCTION;\n" );
    str.append( "\n" );
config_control_design::schema->AddFunction( str );

  //  *****  Initialize the Types
        config_control_design::t_text = new TypeDescriptor (
                  "Text",        // Name
                  sdaiSTRING,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "STRING");        // Description
        config_control_design::schema->AddType(config_control_design::t_text);
        config_control_design::t_dimension_count = new TypeDescriptor (
                  "Dimension_Count",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_dimension_count);
    config_control_design::t_dimension_count->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "SELF > 0\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_dimension_count->_where_rules->Append( wr );
        config_control_design::t_volume_measure = new TypeDescriptor (
                  "Volume_Measure",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_volume_measure);
        config_control_design::t_year_number = new TypeDescriptor (
                  "Year_Number",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_year_number);
        config_control_design::t_week_in_year_number = new TypeDescriptor (
                  "Week_In_Year_Number",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_week_in_year_number);
    config_control_design::t_week_in_year_number->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "( 1 <= SELF ) AND ( SELF <= 53 )\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_week_in_year_number->_where_rules->Append( wr );
        config_control_design::t_area_measure = new TypeDescriptor (
                  "Area_Measure",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_area_measure);
        config_control_design::t_hour_in_day = new TypeDescriptor (
                  "Hour_In_Day",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_hour_in_day);
    config_control_design::t_hour_in_day->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "( 0 <= SELF ) AND ( SELF < 24 )\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_hour_in_day->_where_rules->Append( wr );
        config_control_design::t_month_in_year_number = new TypeDescriptor (
                  "Month_In_Year_Number",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_month_in_year_number);
    config_control_design::t_month_in_year_number->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "( 1 <= SELF ) AND ( SELF <= 12 )\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_month_in_year_number->_where_rules->Append( wr );
        config_control_design::t_length_measure = new TypeDescriptor (
                  "Length_Measure",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_length_measure);
        config_control_design::t_count_measure = new TypeDescriptor (
                  "Count_Measure",        // Name
                  sdaiNUMBER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "NUMBER");        // Description
        config_control_design::schema->AddType(config_control_design::t_count_measure);
        config_control_design::t_descriptive_measure = new TypeDescriptor (
                  "Descriptive_Measure",        // Name
                  sdaiSTRING,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "STRING");        // Description
        config_control_design::schema->AddType(config_control_design::t_descriptive_measure);
        config_control_design::t_plane_angle_measure = new TypeDescriptor (
                  "Plane_Angle_Measure",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_plane_angle_measure);

        config_control_design::t_list_of_reversible_topology_item = new ListTypeDescriptor (
                  "List_Of_Reversible_Topology_Item",        // Name
                  LIST_TYPE,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "LIST [0:?] OF reversible_topology_item",        // Description
                  (AggregateCreator) create_SdaiList_of_reversible_topology_item);        // Creator function

        config_control_design::schema->AddType(config_control_design::t_list_of_reversible_topology_item);
        config_control_design::t_day_in_month_number = new TypeDescriptor (
                  "Day_In_Month_Number",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_day_in_month_number);
        config_control_design::t_identifier = new TypeDescriptor (
                  "Identifier",        // Name
                  sdaiSTRING,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "STRING");        // Description
        config_control_design::schema->AddType(config_control_design::t_identifier);
        config_control_design::t_parameter_value = new TypeDescriptor (
                  "Parameter_Value",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_parameter_value);
        config_control_design::t_mass_measure = new TypeDescriptor (
                  "Mass_Measure",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_mass_measure);
        config_control_design::t_positive_length_measure = new TypeDescriptor (
                  "Positive_Length_Measure",        // Name
                  REFERENCE_TYPE,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "length_measure");        // Description
        config_control_design::schema->AddType(config_control_design::t_positive_length_measure);
    config_control_design::t_positive_length_measure->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "SELF > 0\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_positive_length_measure->_where_rules->Append( wr );

        config_control_design::t_set_of_reversible_topology_item = new SetTypeDescriptor (
                  "Set_Of_Reversible_Topology_Item",        // Name
                  SET_TYPE,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "SET [0:?] OF reversible_topology_item",        // Description
                  (AggregateCreator) create_SdaiSet_of_reversible_topology_item);        // Creator function

        config_control_design::schema->AddType(config_control_design::t_set_of_reversible_topology_item);
        config_control_design::t_day_in_week_number = new TypeDescriptor (
                  "Day_In_Week_Number",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_day_in_week_number);
    config_control_design::t_day_in_week_number->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "( 1 <= SELF ) AND ( SELF <= 7 )\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_day_in_week_number->_where_rules->Append( wr );
        config_control_design::t_minute_in_hour = new TypeDescriptor (
                  "Minute_In_Hour",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_minute_in_hour);
    config_control_design::t_minute_in_hour->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "( 0 <= SELF ) AND ( SELF <= 59 )\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_minute_in_hour->_where_rules->Append( wr );
        config_control_design::t_context_dependent_measure = new TypeDescriptor (
                  "Context_Dependent_Measure",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_context_dependent_measure);
        config_control_design::t_solid_angle_measure = new TypeDescriptor (
                  "Solid_Angle_Measure",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_solid_angle_measure);
        config_control_design::t_second_in_minute = new TypeDescriptor (
                  "Second_In_Minute",        // Name
                  sdaiREAL,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "REAL");        // Description
        config_control_design::schema->AddType(config_control_design::t_second_in_minute);
    config_control_design::t_second_in_minute->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "( 0 <= SELF ) AND ( SELF < 60 )\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_second_in_minute->_where_rules->Append( wr );
        config_control_design::t_label = new TypeDescriptor (
                  "Label",        // Name
                  sdaiSTRING,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "STRING");        // Description
        config_control_design::schema->AddType(config_control_design::t_label);
        config_control_design::t_day_in_year_number = new TypeDescriptor (
                  "Day_In_Year_Number",        // Name
                  sdaiINTEGER,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "INTEGER");        // Description
        config_control_design::schema->AddType(config_control_design::t_day_in_year_number);
        config_control_design::t_positive_plane_angle_measure = new TypeDescriptor (
                  "Positive_Plane_Angle_Measure",        // Name
                  REFERENCE_TYPE,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "plane_angle_measure");        // Description
        config_control_design::schema->AddType(config_control_design::t_positive_plane_angle_measure);
    config_control_design::t_positive_plane_angle_measure->_where_rules = new Where_rule__list;
        str.clear();
        str.append( "wr1: (" );
    str.append( "SELF > 0\n" );
        str.append( ");\n" );
        wr = new Where_rule( str.c_str() );
        config_control_design::t_positive_plane_angle_measure->_where_rules->Append( wr );
    config_control_design::e_document_usage_constraint = new EntityDescriptor( "Document_Usage_Constraint", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDocument_usage_constraint );
    config_control_design::schema->AddEntity(config_control_design::e_document_usage_constraint);
    config_control_design::e_representation = new EntityDescriptor( "Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRepresentation );
    config_control_design::schema->AddEntity(config_control_design::e_representation);
    config_control_design::e_shape_representation = new EntityDescriptor( "Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiShape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_shape_representation);
    config_control_design::e_faceted_brep_shape_representation = new EntityDescriptor( "Faceted_Brep_Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiFaceted_brep_shape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_faceted_brep_shape_representation);
    config_control_design::e_founded_item = new EntityDescriptor( "Founded_Item", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiFounded_item );
    config_control_design::schema->AddEntity(config_control_design::e_founded_item);
    config_control_design::e_composite_curve_segment = new EntityDescriptor( "Composite_Curve_Segment", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiComposite_curve_segment );
    config_control_design::schema->AddEntity(config_control_design::e_composite_curve_segment);
    config_control_design::e_reparametrised_composite_curve_segment = new EntityDescriptor( "Reparametrised_Composite_Curve_Segment", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiReparametrised_composite_curve_segment );
    config_control_design::schema->AddEntity(config_control_design::e_reparametrised_composite_curve_segment);
    config_control_design::e_representation_item = new EntityDescriptor( "Representation_Item", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRepresentation_item );
    config_control_design::schema->AddEntity(config_control_design::e_representation_item);
    config_control_design::e_geometric_representation_item = new EntityDescriptor( "Geometric_Representation_Item", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiGeometric_representation_item );
    config_control_design::schema->AddEntity(config_control_design::e_geometric_representation_item);
    config_control_design::e_placement = new EntityDescriptor( "Placement", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPlacement );
    config_control_design::schema->AddEntity(config_control_design::e_placement);
    config_control_design::e_axis1_placement = new EntityDescriptor( "Axis1_Placement", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAxis1_placement );
    config_control_design::schema->AddEntity(config_control_design::e_axis1_placement);
    config_control_design::e_curve = new EntityDescriptor( "Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCurve );
    config_control_design::schema->AddEntity(config_control_design::e_curve);
    config_control_design::e_bounded_curve = new EntityDescriptor( "Bounded_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiBounded_curve );
    config_control_design::schema->AddEntity(config_control_design::e_bounded_curve);
    config_control_design::e_b_spline_curve = new EntityDescriptor( "B_Spline_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiB_spline_curve );
    config_control_design::schema->AddEntity(config_control_design::e_b_spline_curve);
    config_control_design::e_bezier_curve = new EntityDescriptor( "Bezier_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiBezier_curve );
    config_control_design::schema->AddEntity(config_control_design::e_bezier_curve);
    config_control_design::e_representation_relationship = new EntityDescriptor( "Representation_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRepresentation_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_representation_relationship);
    config_control_design::e_shape_representation_relationship = new EntityDescriptor( "Shape_Representation_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiShape_representation_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_shape_representation_relationship);
    config_control_design::e_date_and_time = new EntityDescriptor( "Date_And_Time", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDate_and_time );
    config_control_design::schema->AddEntity(config_control_design::e_date_and_time);
    config_control_design::e_product_definition_formation = new EntityDescriptor( "Product_Definition_Formation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition_formation );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition_formation);
    config_control_design::e_product_definition_formation_with_specified_source = new EntityDescriptor( "Product_Definition_Formation_With_Specified_Source", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition_formation_with_specified_source );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition_formation_with_specified_source);
    config_control_design::e_surface = new EntityDescriptor( "Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSurface );
    config_control_design::schema->AddEntity(config_control_design::e_surface);
    config_control_design::e_surface_replica = new EntityDescriptor( "Surface_Replica", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSurface_replica );
    config_control_design::schema->AddEntity(config_control_design::e_surface_replica);
    config_control_design::e_document = new EntityDescriptor( "Document", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDocument );
    config_control_design::schema->AddEntity(config_control_design::e_document);
    config_control_design::e_document_with_class = new EntityDescriptor( "Document_With_Class", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDocument_with_class );
    config_control_design::schema->AddEntity(config_control_design::e_document_with_class);
    config_control_design::e_assembly_component_usage_substitute = new EntityDescriptor( "Assembly_Component_Usage_Substitute", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAssembly_component_usage_substitute );
    config_control_design::schema->AddEntity(config_control_design::e_assembly_component_usage_substitute);
    config_control_design::e_item_defined_transformation = new EntityDescriptor( "Item_Defined_Transformation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiItem_defined_transformation );
    config_control_design::schema->AddEntity(config_control_design::e_item_defined_transformation);
    config_control_design::e_solid_model = new EntityDescriptor( "Solid_Model", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSolid_model );
    config_control_design::schema->AddEntity(config_control_design::e_solid_model);
    config_control_design::e_manifold_solid_brep = new EntityDescriptor( "Manifold_Solid_Brep", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiManifold_solid_brep );
    config_control_design::schema->AddEntity(config_control_design::e_manifold_solid_brep);
    config_control_design::e_faceted_brep = new EntityDescriptor( "Faceted_Brep", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiFaceted_brep );
    config_control_design::schema->AddEntity(config_control_design::e_faceted_brep);
    config_control_design::e_named_unit = new EntityDescriptor( "Named_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiNamed_unit );
    config_control_design::schema->AddEntity(config_control_design::e_named_unit);
    config_control_design::e_mass_unit = new EntityDescriptor( "Mass_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiMass_unit );
    config_control_design::schema->AddEntity(config_control_design::e_mass_unit);
    config_control_design::e_solid_angle_unit = new EntityDescriptor( "Solid_Angle_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSolid_angle_unit );
    config_control_design::schema->AddEntity(config_control_design::e_solid_angle_unit);
    config_control_design::e_bounded_surface = new EntityDescriptor( "Bounded_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiBounded_surface );
    config_control_design::schema->AddEntity(config_control_design::e_bounded_surface);
    config_control_design::e_rectangular_composite_surface = new EntityDescriptor( "Rectangular_Composite_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRectangular_composite_surface );
    config_control_design::schema->AddEntity(config_control_design::e_rectangular_composite_surface);
    config_control_design::e_person_and_organization_role = new EntityDescriptor( "Person_And_Organization_Role", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPerson_and_organization_role );
    config_control_design::schema->AddEntity(config_control_design::e_person_and_organization_role);
    config_control_design::e_elementary_surface = new EntityDescriptor( "Elementary_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiElementary_surface );
    config_control_design::schema->AddEntity(config_control_design::e_elementary_surface);
    config_control_design::e_toroidal_surface = new EntityDescriptor( "Toroidal_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiToroidal_surface );
    config_control_design::schema->AddEntity(config_control_design::e_toroidal_surface);
    config_control_design::e_action_status = new EntityDescriptor( "Action_Status", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAction_status );
    config_control_design::schema->AddEntity(config_control_design::e_action_status);
    config_control_design::e_approval_role = new EntityDescriptor( "Approval_Role", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApproval_role );
    config_control_design::schema->AddEntity(config_control_design::e_approval_role);
    config_control_design::e_organization_relationship = new EntityDescriptor( "Organization_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOrganization_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_organization_relationship);
    config_control_design::e_composite_curve = new EntityDescriptor( "Composite_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiComposite_curve );
    config_control_design::schema->AddEntity(config_control_design::e_composite_curve);
    config_control_design::e_b_spline_curve_with_knots = new EntityDescriptor( "B_Spline_Curve_With_Knots", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiB_spline_curve_with_knots );
    config_control_design::schema->AddEntity(config_control_design::e_b_spline_curve_with_knots);
    config_control_design::e_representation_context = new EntityDescriptor( "Representation_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRepresentation_context );
    config_control_design::schema->AddEntity(config_control_design::e_representation_context);
    config_control_design::e_global_unit_assigned_context = new EntityDescriptor( "Global_Unit_Assigned_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiGlobal_unit_assigned_context );
    config_control_design::schema->AddEntity(config_control_design::e_global_unit_assigned_context);
    config_control_design::e_address = new EntityDescriptor( "Address", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAddress );
    config_control_design::schema->AddEntity(config_control_design::e_address);
    config_control_design::e_organizational_address = new EntityDescriptor( "Organizational_Address", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOrganizational_address );
    config_control_design::schema->AddEntity(config_control_design::e_organizational_address);
    config_control_design::e_personal_address = new EntityDescriptor( "Personal_Address", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPersonal_address );
    config_control_design::schema->AddEntity(config_control_design::e_personal_address);
    config_control_design::e_shape_aspect_relationship = new EntityDescriptor( "Shape_Aspect_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiShape_aspect_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_shape_aspect_relationship);
    config_control_design::e_advanced_brep_shape_representation = new EntityDescriptor( "Advanced_Brep_Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAdvanced_brep_shape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_advanced_brep_shape_representation);
    config_control_design::e_topological_representation_item = new EntityDescriptor( "Topological_Representation_Item", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiTopological_representation_item );
    config_control_design::schema->AddEntity(config_control_design::e_topological_representation_item);
    config_control_design::e_face = new EntityDescriptor( "Face", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiFace );
    config_control_design::schema->AddEntity(config_control_design::e_face);
    config_control_design::e_face_surface = new EntityDescriptor( "Face_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiFace_surface );
    config_control_design::schema->AddEntity(config_control_design::e_face_surface);
    config_control_design::e_property_definition_representation = new EntityDescriptor( "Property_Definition_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProperty_definition_representation );
    config_control_design::schema->AddEntity(config_control_design::e_property_definition_representation);
    config_control_design::e_security_classification_level = new EntityDescriptor( "Security_Classification_Level", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSecurity_classification_level );
    config_control_design::schema->AddEntity(config_control_design::e_security_classification_level);
    config_control_design::e_b_spline_surface = new EntityDescriptor( "B_Spline_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiB_spline_surface );
    config_control_design::schema->AddEntity(config_control_design::e_b_spline_surface);
    config_control_design::e_b_spline_surface_with_knots = new EntityDescriptor( "B_Spline_Surface_With_Knots", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiB_spline_surface_with_knots );
    config_control_design::schema->AddEntity(config_control_design::e_b_spline_surface_with_knots);
    config_control_design::e_composite_curve_on_surface = new EntityDescriptor( "Composite_Curve_On_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiComposite_curve_on_surface );
    config_control_design::schema->AddEntity(config_control_design::e_composite_curve_on_surface);
    config_control_design::e_boundary_curve = new EntityDescriptor( "Boundary_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiBoundary_curve );
    config_control_design::schema->AddEntity(config_control_design::e_boundary_curve);
    config_control_design::e_outer_boundary_curve = new EntityDescriptor( "Outer_Boundary_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOuter_boundary_curve );
    config_control_design::schema->AddEntity(config_control_design::e_outer_boundary_curve);
    config_control_design::e_parametric_representation_context = new EntityDescriptor( "Parametric_Representation_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiParametric_representation_context );
    config_control_design::schema->AddEntity(config_control_design::e_parametric_representation_context);
    config_control_design::e_surface_patch = new EntityDescriptor( "Surface_Patch", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSurface_patch );
    config_control_design::schema->AddEntity(config_control_design::e_surface_patch);
    config_control_design::e_action_request_status = new EntityDescriptor( "Action_Request_Status", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAction_request_status );
    config_control_design::schema->AddEntity(config_control_design::e_action_request_status);
    config_control_design::e_measure_with_unit = new EntityDescriptor( "Measure_With_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiMeasure_with_unit );
    config_control_design::schema->AddEntity(config_control_design::e_measure_with_unit);
    config_control_design::e_area_measure_with_unit = new EntityDescriptor( "Area_Measure_With_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiArea_measure_with_unit );
    config_control_design::schema->AddEntity(config_control_design::e_area_measure_with_unit);
    config_control_design::e_person = new EntityDescriptor( "Person", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPerson );
    config_control_design::schema->AddEntity(config_control_design::e_person);
    config_control_design::e_quasi_uniform_surface = new EntityDescriptor( "Quasi_Uniform_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiQuasi_uniform_surface );
    config_control_design::schema->AddEntity(config_control_design::e_quasi_uniform_surface);
    config_control_design::e_edge = new EntityDescriptor( "Edge", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiEdge );
    config_control_design::schema->AddEntity(config_control_design::e_edge);
    config_control_design::e_oriented_edge = new EntityDescriptor( "Oriented_Edge", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOriented_edge );
    config_control_design::schema->AddEntity(config_control_design::e_oriented_edge);
    config_control_design::e_functionally_defined_transformation = new EntityDescriptor( "Functionally_Defined_Transformation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiFunctionally_defined_transformation );
    config_control_design::schema->AddEntity(config_control_design::e_functionally_defined_transformation);
    config_control_design::e_cartesian_transformation_operator = new EntityDescriptor( "Cartesian_Transformation_Operator", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCartesian_transformation_operator );
    config_control_design::schema->AddEntity(config_control_design::e_cartesian_transformation_operator);
    config_control_design::e_cartesian_transformation_operator_3d = new EntityDescriptor( "Cartesian_Transformation_Operator_3d", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCartesian_transformation_operator_3d );
    config_control_design::schema->AddEntity(config_control_design::e_cartesian_transformation_operator_3d);
    config_control_design::e_action_request_assignment = new EntityDescriptor( "Action_Request_Assignment", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiAction_request_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_action_request_assignment);
    config_control_design::e_change_request = new EntityDescriptor( "Change_Request", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiChange_request );
    config_control_design::schema->AddEntity(config_control_design::e_change_request);
    config_control_design::e_point = new EntityDescriptor( "Point", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPoint );
    config_control_design::schema->AddEntity(config_control_design::e_point);
    config_control_design::e_degenerate_pcurve = new EntityDescriptor( "Degenerate_Pcurve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDegenerate_pcurve );
    config_control_design::schema->AddEntity(config_control_design::e_degenerate_pcurve);
    config_control_design::e_date_and_time_assignment = new EntityDescriptor( "Date_And_Time_Assignment", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiDate_and_time_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_date_and_time_assignment);
    config_control_design::e_cc_design_date_and_time_assignment = new EntityDescriptor( "Cc_Design_Date_And_Time_Assignment", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCc_design_date_and_time_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_cc_design_date_and_time_assignment);
    config_control_design::e_approval_relationship = new EntityDescriptor( "Approval_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApproval_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_approval_relationship);
    config_control_design::e_geometric_set = new EntityDescriptor( "Geometric_Set", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiGeometric_set );
    config_control_design::schema->AddEntity(config_control_design::e_geometric_set);
    config_control_design::e_uniform_surface = new EntityDescriptor( "Uniform_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiUniform_surface );
    config_control_design::schema->AddEntity(config_control_design::e_uniform_surface);
    config_control_design::e_certification = new EntityDescriptor( "Certification", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCertification );
    config_control_design::schema->AddEntity(config_control_design::e_certification);
    config_control_design::e_edge_based_wireframe_model = new EntityDescriptor( "Edge_Based_Wireframe_Model", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiEdge_based_wireframe_model );
    config_control_design::schema->AddEntity(config_control_design::e_edge_based_wireframe_model);
    config_control_design::e_surface_curve = new EntityDescriptor( "Surface_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSurface_curve );
    config_control_design::schema->AddEntity(config_control_design::e_surface_curve);
    config_control_design::e_bounded_surface_curve = new EntityDescriptor( "Bounded_Surface_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiBounded_surface_curve );
    config_control_design::schema->AddEntity(config_control_design::e_bounded_surface_curve);
    config_control_design::e_conic = new EntityDescriptor( "Conic", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiConic );
    config_control_design::schema->AddEntity(config_control_design::e_conic);
    config_control_design::e_hyperbola = new EntityDescriptor( "Hyperbola", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiHyperbola );
    config_control_design::schema->AddEntity(config_control_design::e_hyperbola);
    config_control_design::e_property_definition = new EntityDescriptor( "Property_Definition", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProperty_definition );
    config_control_design::schema->AddEntity(config_control_design::e_property_definition);
    config_control_design::e_degenerate_toroidal_surface = new EntityDescriptor( "Degenerate_Toroidal_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDegenerate_toroidal_surface );
    config_control_design::schema->AddEntity(config_control_design::e_degenerate_toroidal_surface);
    config_control_design::e_product_definition = new EntityDescriptor( "Product_Definition", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition);
    config_control_design::e_product_definition_with_associated_documents = new EntityDescriptor( "Product_Definition_With_Associated_Documents", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition_with_associated_documents );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition_with_associated_documents);
    config_control_design::e_path = new EntityDescriptor( "Path", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPath );
    config_control_design::schema->AddEntity(config_control_design::e_path);
    config_control_design::e_action_assignment = new EntityDescriptor( "Action_Assignment", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiAction_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_action_assignment);
    config_control_design::e_start_work = new EntityDescriptor( "Start_Work", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiStart_work );
    config_control_design::schema->AddEntity(config_control_design::e_start_work);
    config_control_design::e_approval = new EntityDescriptor( "Approval", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApproval );
    config_control_design::schema->AddEntity(config_control_design::e_approval);
    config_control_design::e_loop = new EntityDescriptor( "Loop", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiLoop );
    config_control_design::schema->AddEntity(config_control_design::e_loop);
    config_control_design::e_poly_loop = new EntityDescriptor( "Poly_Loop", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPoly_loop );
    config_control_design::schema->AddEntity(config_control_design::e_poly_loop);
    config_control_design::e_point_on_surface = new EntityDescriptor( "Point_On_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPoint_on_surface );
    config_control_design::schema->AddEntity(config_control_design::e_point_on_surface);
    config_control_design::e_product_concept = new EntityDescriptor( "Product_Concept", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_concept );
    config_control_design::schema->AddEntity(config_control_design::e_product_concept);
    config_control_design::e_rational_b_spline_curve = new EntityDescriptor( "Rational_B_Spline_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRational_b_spline_curve );
    config_control_design::schema->AddEntity(config_control_design::e_rational_b_spline_curve);
    config_control_design::e_start_request = new EntityDescriptor( "Start_Request", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiStart_request );
    config_control_design::schema->AddEntity(config_control_design::e_start_request);
    config_control_design::e_edge_based_wireframe_shape_representation = new EntityDescriptor( "Edge_Based_Wireframe_Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiEdge_based_wireframe_shape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_edge_based_wireframe_shape_representation);
    config_control_design::e_polyline = new EntityDescriptor( "Polyline", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPolyline );
    config_control_design::schema->AddEntity(config_control_design::e_polyline);
    config_control_design::e_spherical_surface = new EntityDescriptor( "Spherical_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSpherical_surface );
    config_control_design::schema->AddEntity(config_control_design::e_spherical_surface);
    config_control_design::e_contract_assignment = new EntityDescriptor( "Contract_Assignment", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiContract_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_contract_assignment);
    config_control_design::e_cc_design_contract = new EntityDescriptor( "Cc_Design_Contract", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCc_design_contract );
    config_control_design::schema->AddEntity(config_control_design::e_cc_design_contract);
    config_control_design::e_configuration_item = new EntityDescriptor( "Configuration_Item", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiConfiguration_item );
    config_control_design::schema->AddEntity(config_control_design::e_configuration_item);
    config_control_design::e_date = new EntityDescriptor( "Date", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDate );
    config_control_design::schema->AddEntity(config_control_design::e_date);
    config_control_design::e_week_of_year_and_day_date = new EntityDescriptor( "Week_Of_Year_And_Day_Date", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiWeek_of_year_and_day_date );
    config_control_design::schema->AddEntity(config_control_design::e_week_of_year_and_day_date);
    config_control_design::e_effectivity = new EntityDescriptor( "Effectivity", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiEffectivity );
    config_control_design::schema->AddEntity(config_control_design::e_effectivity);
    config_control_design::e_lot_effectivity = new EntityDescriptor( "Lot_Effectivity", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiLot_effectivity );
    config_control_design::schema->AddEntity(config_control_design::e_lot_effectivity);
    config_control_design::e_application_context_element = new EntityDescriptor( "Application_Context_Element", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApplication_context_element );
    config_control_design::schema->AddEntity(config_control_design::e_application_context_element);
    config_control_design::e_shape_definition_representation = new EntityDescriptor( "Shape_Definition_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiShape_definition_representation );
    config_control_design::schema->AddEntity(config_control_design::e_shape_definition_representation);
    config_control_design::e_connected_face_set = new EntityDescriptor( "Connected_Face_Set", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiConnected_face_set );
    config_control_design::schema->AddEntity(config_control_design::e_connected_face_set);
    config_control_design::e_closed_shell = new EntityDescriptor( "Closed_Shell", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiClosed_shell );
    config_control_design::schema->AddEntity(config_control_design::e_closed_shell);
    config_control_design::e_application_protocol_definition = new EntityDescriptor( "Application_Protocol_Definition", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApplication_protocol_definition );
    config_control_design::schema->AddEntity(config_control_design::e_application_protocol_definition);
    config_control_design::e_product_category = new EntityDescriptor( "Product_Category", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_category );
    config_control_design::schema->AddEntity(config_control_design::e_product_category);
    config_control_design::e_product_related_product_category = new EntityDescriptor( "Product_Related_Product_Category", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_related_product_category );
    config_control_design::schema->AddEntity(config_control_design::e_product_related_product_category);
    config_control_design::e_action_method = new EntityDescriptor( "Action_Method", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAction_method );
    config_control_design::schema->AddEntity(config_control_design::e_action_method);
    config_control_design::e_product_definition_shape = new EntityDescriptor( "Product_Definition_Shape", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition_shape );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition_shape);
    config_control_design::e_seam_curve = new EntityDescriptor( "Seam_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSeam_curve );
    config_control_design::schema->AddEntity(config_control_design::e_seam_curve);
    config_control_design::e_configuration_design = new EntityDescriptor( "Configuration_Design", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiConfiguration_design );
    config_control_design::schema->AddEntity(config_control_design::e_configuration_design);
    config_control_design::e_context_dependent_unit = new EntityDescriptor( "Context_Dependent_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiContext_dependent_unit );
    config_control_design::schema->AddEntity(config_control_design::e_context_dependent_unit);
    config_control_design::e_action = new EntityDescriptor( "Action", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAction );
    config_control_design::schema->AddEntity(config_control_design::e_action);
    config_control_design::e_executed_action = new EntityDescriptor( "Executed_Action", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiExecuted_action );
    config_control_design::schema->AddEntity(config_control_design::e_executed_action);
    config_control_design::e_product_definition_relationship = new EntityDescriptor( "Product_Definition_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition_relationship);
    config_control_design::e_product_definition_usage = new EntityDescriptor( "Product_Definition_Usage", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition_usage );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition_usage);
    config_control_design::e_assembly_component_usage = new EntityDescriptor( "Assembly_Component_Usage", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAssembly_component_usage );
    config_control_design::schema->AddEntity(config_control_design::e_assembly_component_usage);
    config_control_design::e_specified_higher_usage_occurrence = new EntityDescriptor( "Specified_Higher_Usage_Occurrence", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSpecified_higher_usage_occurrence );
    config_control_design::schema->AddEntity(config_control_design::e_specified_higher_usage_occurrence);
    config_control_design::e_mapped_item = new EntityDescriptor( "Mapped_Item", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiMapped_item );
    config_control_design::schema->AddEntity(config_control_design::e_mapped_item);
    config_control_design::e_approval_assignment = new EntityDescriptor( "Approval_Assignment", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiApproval_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_approval_assignment);
    config_control_design::e_cc_design_approval = new EntityDescriptor( "Cc_Design_Approval", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCc_design_approval );
    config_control_design::schema->AddEntity(config_control_design::e_cc_design_approval);
    config_control_design::e_product_definition_context = new EntityDescriptor( "Product_Definition_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition_context );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition_context);
    config_control_design::e_design_context = new EntityDescriptor( "Design_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDesign_context );
    config_control_design::schema->AddEntity(config_control_design::e_design_context);
    config_control_design::e_swept_surface = new EntityDescriptor( "Swept_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSwept_surface );
    config_control_design::schema->AddEntity(config_control_design::e_swept_surface);
    config_control_design::e_surface_of_revolution = new EntityDescriptor( "Surface_Of_Revolution", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSurface_of_revolution );
    config_control_design::schema->AddEntity(config_control_design::e_surface_of_revolution);
    config_control_design::e_vector = new EntityDescriptor( "Vector", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiVector );
    config_control_design::schema->AddEntity(config_control_design::e_vector);
    config_control_design::e_solid_angle_measure_with_unit = new EntityDescriptor( "Solid_Angle_Measure_With_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSolid_angle_measure_with_unit );
    config_control_design::schema->AddEntity(config_control_design::e_solid_angle_measure_with_unit);
    config_control_design::e_person_and_organization_assignment = new EntityDescriptor( "Person_And_Organization_Assignment", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiPerson_and_organization_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_person_and_organization_assignment);
    config_control_design::e_trimmed_curve = new EntityDescriptor( "Trimmed_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiTrimmed_curve );
    config_control_design::schema->AddEntity(config_control_design::e_trimmed_curve);
    config_control_design::e_vertex = new EntityDescriptor( "Vertex", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiVertex );
    config_control_design::schema->AddEntity(config_control_design::e_vertex);
    config_control_design::e_quantified_assembly_component_usage = new EntityDescriptor( "Quantified_Assembly_Component_Usage", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiQuantified_assembly_component_usage );
    config_control_design::schema->AddEntity(config_control_design::e_quantified_assembly_component_usage);
    config_control_design::e_product_category_relationship = new EntityDescriptor( "Product_Category_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_category_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_product_category_relationship);
    config_control_design::e_organization = new EntityDescriptor( "Organization", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOrganization );
    config_control_design::schema->AddEntity(config_control_design::e_organization);
    config_control_design::e_cartesian_point = new EntityDescriptor( "Cartesian_Point", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCartesian_point );
    config_control_design::schema->AddEntity(config_control_design::e_cartesian_point);
    config_control_design::e_ellipse = new EntityDescriptor( "Ellipse", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiEllipse );
    config_control_design::schema->AddEntity(config_control_design::e_ellipse);
    config_control_design::e_global_uncertainty_assigned_context = new EntityDescriptor( "Global_Uncertainty_Assigned_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiGlobal_uncertainty_assigned_context );
    config_control_design::schema->AddEntity(config_control_design::e_global_uncertainty_assigned_context);
    config_control_design::e_evaluated_degenerate_pcurve = new EntityDescriptor( "Evaluated_Degenerate_Pcurve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiEvaluated_degenerate_pcurve );
    config_control_design::schema->AddEntity(config_control_design::e_evaluated_degenerate_pcurve);
    config_control_design::e_geometrically_bounded_wireframe_shape_representation = new EntityDescriptor( "Geometrically_Bounded_Wireframe_Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiGeometrically_bounded_wireframe_shape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_geometrically_bounded_wireframe_shape_representation);
    config_control_design::e_plane_angle_unit = new EntityDescriptor( "Plane_Angle_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPlane_angle_unit );
    config_control_design::schema->AddEntity(config_control_design::e_plane_angle_unit);
    config_control_design::e_shell_based_wireframe_model = new EntityDescriptor( "Shell_Based_Wireframe_Model", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiShell_based_wireframe_model );
    config_control_design::schema->AddEntity(config_control_design::e_shell_based_wireframe_model);
    config_control_design::e_application_context = new EntityDescriptor( "Application_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApplication_context );
    config_control_design::schema->AddEntity(config_control_design::e_application_context);
    config_control_design::e_open_shell = new EntityDescriptor( "Open_Shell", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOpen_shell );
    config_control_design::schema->AddEntity(config_control_design::e_open_shell);
    config_control_design::e_axis2_placement_3d = new EntityDescriptor( "Axis2_Placement_3d", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAxis2_placement_3d );
    config_control_design::schema->AddEntity(config_control_design::e_axis2_placement_3d);
    config_control_design::e_security_classification_assignment = new EntityDescriptor( "Security_Classification_Assignment", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiSecurity_classification_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_security_classification_assignment);
    config_control_design::e_cc_design_security_classification = new EntityDescriptor( "Cc_Design_Security_Classification", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCc_design_security_classification );
    config_control_design::schema->AddEntity(config_control_design::e_cc_design_security_classification);
    config_control_design::e_curve_replica = new EntityDescriptor( "Curve_Replica", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCurve_replica );
    config_control_design::schema->AddEntity(config_control_design::e_curve_replica);
    config_control_design::e_vertex_loop = new EntityDescriptor( "Vertex_Loop", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiVertex_loop );
    config_control_design::schema->AddEntity(config_control_design::e_vertex_loop);
    config_control_design::e_calendar_date = new EntityDescriptor( "Calendar_Date", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCalendar_date );
    config_control_design::schema->AddEntity(config_control_design::e_calendar_date);
    config_control_design::e_edge_loop = new EntityDescriptor( "Edge_Loop", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiEdge_loop );
    config_control_design::schema->AddEntity(config_control_design::e_edge_loop);
    config_control_design::e_oriented_closed_shell = new EntityDescriptor( "Oriented_Closed_Shell", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOriented_closed_shell );
    config_control_design::schema->AddEntity(config_control_design::e_oriented_closed_shell);
    config_control_design::e_design_make_from_relationship = new EntityDescriptor( "Design_Make_From_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDesign_make_from_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_design_make_from_relationship);
    config_control_design::e_shell_based_surface_model = new EntityDescriptor( "Shell_Based_Surface_Model", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiShell_based_surface_model );
    config_control_design::schema->AddEntity(config_control_design::e_shell_based_surface_model);
    config_control_design::e_face_bound = new EntityDescriptor( "Face_Bound", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiFace_bound );
    config_control_design::schema->AddEntity(config_control_design::e_face_bound);
    config_control_design::e_representation_relationship_with_transformation = new EntityDescriptor( "Representation_Relationship_With_Transformation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRepresentation_relationship_with_transformation );
    config_control_design::schema->AddEntity(config_control_design::e_representation_relationship_with_transformation);
    config_control_design::e_oriented_face = new EntityDescriptor( "Oriented_Face", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOriented_face );
    config_control_design::schema->AddEntity(config_control_design::e_oriented_face);
    config_control_design::e_contract_type = new EntityDescriptor( "Contract_Type", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiContract_type );
    config_control_design::schema->AddEntity(config_control_design::e_contract_type);
    config_control_design::e_pcurve = new EntityDescriptor( "Pcurve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPcurve );
    config_control_design::schema->AddEntity(config_control_design::e_pcurve);
    config_control_design::e_bounded_pcurve = new EntityDescriptor( "Bounded_Pcurve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiBounded_pcurve );
    config_control_design::schema->AddEntity(config_control_design::e_bounded_pcurve);
    config_control_design::e_certification_assignment = new EntityDescriptor( "Certification_Assignment", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiCertification_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_certification_assignment);
    config_control_design::e_cc_design_certification = new EntityDescriptor( "Cc_Design_Certification", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCc_design_certification );
    config_control_design::schema->AddEntity(config_control_design::e_cc_design_certification);
    config_control_design::e_plane = new EntityDescriptor( "Plane", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPlane );
    config_control_design::schema->AddEntity(config_control_design::e_plane);
    config_control_design::e_change = new EntityDescriptor( "Change", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiChange );
    config_control_design::schema->AddEntity(config_control_design::e_change);
    config_control_design::e_circle = new EntityDescriptor( "Circle", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCircle );
    config_control_design::schema->AddEntity(config_control_design::e_circle);
    config_control_design::e_line = new EntityDescriptor( "Line", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiLine );
    config_control_design::schema->AddEntity(config_control_design::e_line);
    config_control_design::e_contract = new EntityDescriptor( "Contract", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiContract );
    config_control_design::schema->AddEntity(config_control_design::e_contract);
    config_control_design::e_product_definition_effectivity = new EntityDescriptor( "Product_Definition_Effectivity", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_definition_effectivity );
    config_control_design::schema->AddEntity(config_control_design::e_product_definition_effectivity);
    config_control_design::e_configuration_effectivity = new EntityDescriptor( "Configuration_Effectivity", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiConfiguration_effectivity );
    config_control_design::schema->AddEntity(config_control_design::e_configuration_effectivity);
    config_control_design::e_product = new EntityDescriptor( "Product", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct );
    config_control_design::schema->AddEntity(config_control_design::e_product);
    config_control_design::e_document_relationship = new EntityDescriptor( "Document_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDocument_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_document_relationship);
    config_control_design::e_versioned_action_request = new EntityDescriptor( "Versioned_Action_Request", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiVersioned_action_request );
    config_control_design::schema->AddEntity(config_control_design::e_versioned_action_request);
    config_control_design::e_face_outer_bound = new EntityDescriptor( "Face_Outer_Bound", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiFace_outer_bound );
    config_control_design::schema->AddEntity(config_control_design::e_face_outer_bound);
    config_control_design::e_organizational_project = new EntityDescriptor( "Organizational_Project", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOrganizational_project );
    config_control_design::schema->AddEntity(config_control_design::e_organizational_project);
    config_control_design::e_ordinal_date = new EntityDescriptor( "Ordinal_Date", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOrdinal_date );
    config_control_design::schema->AddEntity(config_control_design::e_ordinal_date);
    config_control_design::e_rectangular_trimmed_surface = new EntityDescriptor( "Rectangular_Trimmed_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRectangular_trimmed_surface );
    config_control_design::schema->AddEntity(config_control_design::e_rectangular_trimmed_surface);
    config_control_design::e_cc_design_person_and_organization_assignment = new EntityDescriptor( "Cc_Design_Person_And_Organization_Assignment", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCc_design_person_and_organization_assignment );
    config_control_design::schema->AddEntity(config_control_design::e_cc_design_person_and_organization_assignment);
    config_control_design::e_definitional_representation = new EntityDescriptor( "Definitional_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDefinitional_representation );
    config_control_design::schema->AddEntity(config_control_design::e_definitional_representation);
    config_control_design::e_approval_person_organization = new EntityDescriptor( "Approval_Person_Organization", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApproval_person_organization );
    config_control_design::schema->AddEntity(config_control_design::e_approval_person_organization);
    config_control_design::e_curve_bounded_surface = new EntityDescriptor( "Curve_Bounded_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCurve_bounded_surface );
    config_control_design::schema->AddEntity(config_control_design::e_curve_bounded_surface);
    config_control_design::e_parabola = new EntityDescriptor( "Parabola", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiParabola );
    config_control_design::schema->AddEntity(config_control_design::e_parabola);
    config_control_design::e_quasi_uniform_curve = new EntityDescriptor( "Quasi_Uniform_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiQuasi_uniform_curve );
    config_control_design::schema->AddEntity(config_control_design::e_quasi_uniform_curve);
    config_control_design::e_uncertainty_measure_with_unit = new EntityDescriptor( "Uncertainty_Measure_With_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiUncertainty_measure_with_unit );
    config_control_design::schema->AddEntity(config_control_design::e_uncertainty_measure_with_unit);
    config_control_design::e_uniform_curve = new EntityDescriptor( "Uniform_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiUniform_curve );
    config_control_design::schema->AddEntity(config_control_design::e_uniform_curve);
    config_control_design::e_geometric_curve_set = new EntityDescriptor( "Geometric_Curve_Set", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiGeometric_curve_set );
    config_control_design::schema->AddEntity(config_control_design::e_geometric_curve_set);
    config_control_design::e_length_unit = new EntityDescriptor( "Length_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiLength_unit );
    config_control_design::schema->AddEntity(config_control_design::e_length_unit);
    config_control_design::e_length_measure_with_unit = new EntityDescriptor( "Length_Measure_With_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiLength_measure_with_unit );
    config_control_design::schema->AddEntity(config_control_design::e_length_measure_with_unit);
    config_control_design::e_product_concept_context = new EntityDescriptor( "Product_Concept_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_concept_context );
    config_control_design::schema->AddEntity(config_control_design::e_product_concept_context);
    config_control_design::e_rational_b_spline_surface = new EntityDescriptor( "Rational_B_Spline_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRational_b_spline_surface );
    config_control_design::schema->AddEntity(config_control_design::e_rational_b_spline_surface);
    config_control_design::e_local_time = new EntityDescriptor( "Local_Time", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiLocal_time );
    config_control_design::schema->AddEntity(config_control_design::e_local_time);
    config_control_design::e_next_assembly_usage_occurrence = new EntityDescriptor( "Next_Assembly_Usage_Occurrence", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiNext_assembly_usage_occurrence );
    config_control_design::schema->AddEntity(config_control_design::e_next_assembly_usage_occurrence);
    config_control_design::e_conversion_based_unit = new EntityDescriptor( "Conversion_Based_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiConversion_based_unit );
    config_control_design::schema->AddEntity(config_control_design::e_conversion_based_unit);
    config_control_design::e_vertex_point = new EntityDescriptor( "Vertex_Point", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiVertex_point );
    config_control_design::schema->AddEntity(config_control_design::e_vertex_point);
    config_control_design::e_dimensional_exponents = new EntityDescriptor( "Dimensional_Exponents", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDimensional_exponents );
    config_control_design::schema->AddEntity(config_control_design::e_dimensional_exponents);
    config_control_design::e_product_context = new EntityDescriptor( "Product_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiProduct_context );
    config_control_design::schema->AddEntity(config_control_design::e_product_context);
    config_control_design::e_offset_surface = new EntityDescriptor( "Offset_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOffset_surface );
    config_control_design::schema->AddEntity(config_control_design::e_offset_surface);
    config_control_design::e_context_dependent_shape_representation = new EntityDescriptor( "Context_Dependent_Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiContext_dependent_shape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_context_dependent_shape_representation);
    config_control_design::e_geometric_representation_context = new EntityDescriptor( "Geometric_Representation_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiGeometric_representation_context );
    config_control_design::schema->AddEntity(config_control_design::e_geometric_representation_context);
    config_control_design::e_mass_measure_with_unit = new EntityDescriptor( "Mass_Measure_With_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiMass_measure_with_unit );
    config_control_design::schema->AddEntity(config_control_design::e_mass_measure_with_unit);
    config_control_design::e_si_unit = new EntityDescriptor( "Si_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSi_unit );
    config_control_design::schema->AddEntity(config_control_design::e_si_unit);
    config_control_design::e_document_reference = new EntityDescriptor( "Document_Reference", config_control_design::schema, LTrue, LFalse, (Creator) create_SdaiDocument_reference );
    config_control_design::schema->AddEntity(config_control_design::e_document_reference);
    config_control_design::e_vertex_shell = new EntityDescriptor( "Vertex_Shell", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiVertex_shell );
    config_control_design::schema->AddEntity(config_control_design::e_vertex_shell);
    config_control_design::e_promissory_usage_occurrence = new EntityDescriptor( "Promissory_Usage_Occurrence", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPromissory_usage_occurrence );
    config_control_design::schema->AddEntity(config_control_design::e_promissory_usage_occurrence);
    config_control_design::e_plane_angle_measure_with_unit = new EntityDescriptor( "Plane_Angle_Measure_With_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPlane_angle_measure_with_unit );
    config_control_design::schema->AddEntity(config_control_design::e_plane_angle_measure_with_unit);
    config_control_design::e_shape_aspect = new EntityDescriptor( "Shape_Aspect", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiShape_aspect );
    config_control_design::schema->AddEntity(config_control_design::e_shape_aspect);
    config_control_design::e_volume_measure_with_unit = new EntityDescriptor( "Volume_Measure_With_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiVolume_measure_with_unit );
    config_control_design::schema->AddEntity(config_control_design::e_volume_measure_with_unit);
    config_control_design::e_action_request_solution = new EntityDescriptor( "Action_Request_Solution", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAction_request_solution );
    config_control_design::schema->AddEntity(config_control_design::e_action_request_solution);
    config_control_design::e_axis2_placement_2d = new EntityDescriptor( "Axis2_Placement_2d", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAxis2_placement_2d );
    config_control_design::schema->AddEntity(config_control_design::e_axis2_placement_2d);
    config_control_design::e_directed_action = new EntityDescriptor( "Directed_Action", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDirected_action );
    config_control_design::schema->AddEntity(config_control_design::e_directed_action);
    config_control_design::e_manifold_surface_shape_representation = new EntityDescriptor( "Manifold_Surface_Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiManifold_surface_shape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_manifold_surface_shape_representation);
    config_control_design::e_geometrically_bounded_surface_shape_representation = new EntityDescriptor( "Geometrically_Bounded_Surface_Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiGeometrically_bounded_surface_shape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_geometrically_bounded_surface_shape_representation);
    config_control_design::e_point_replica = new EntityDescriptor( "Point_Replica", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPoint_replica );
    config_control_design::schema->AddEntity(config_control_design::e_point_replica);
    config_control_design::e_cc_design_specification_reference = new EntityDescriptor( "Cc_Design_Specification_Reference", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCc_design_specification_reference );
    config_control_design::schema->AddEntity(config_control_design::e_cc_design_specification_reference);
    config_control_design::e_coordinated_universal_time_offset = new EntityDescriptor( "Coordinated_Universal_Time_Offset", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCoordinated_universal_time_offset );
    config_control_design::schema->AddEntity(config_control_design::e_coordinated_universal_time_offset);
    config_control_design::e_direction = new EntityDescriptor( "Direction", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDirection );
    config_control_design::schema->AddEntity(config_control_design::e_direction);
    config_control_design::e_approval_status = new EntityDescriptor( "Approval_Status", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApproval_status );
    config_control_design::schema->AddEntity(config_control_design::e_approval_status);
    config_control_design::e_oriented_path = new EntityDescriptor( "Oriented_Path", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOriented_path );
    config_control_design::schema->AddEntity(config_control_design::e_oriented_path);
    config_control_design::e_representation_map = new EntityDescriptor( "Representation_Map", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiRepresentation_map );
    config_control_design::schema->AddEntity(config_control_design::e_representation_map);
    config_control_design::e_dated_effectivity = new EntityDescriptor( "Dated_Effectivity", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDated_effectivity );
    config_control_design::schema->AddEntity(config_control_design::e_dated_effectivity);
    config_control_design::e_volume_unit = new EntityDescriptor( "Volume_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiVolume_unit );
    config_control_design::schema->AddEntity(config_control_design::e_volume_unit);
    config_control_design::e_bezier_surface = new EntityDescriptor( "Bezier_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiBezier_surface );
    config_control_design::schema->AddEntity(config_control_design::e_bezier_surface);
    config_control_design::e_cylindrical_surface = new EntityDescriptor( "Cylindrical_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCylindrical_surface );
    config_control_design::schema->AddEntity(config_control_design::e_cylindrical_surface);
    config_control_design::e_person_and_organization = new EntityDescriptor( "Person_And_Organization", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPerson_and_organization );
    config_control_design::schema->AddEntity(config_control_design::e_person_and_organization);
    config_control_design::e_brep_with_voids = new EntityDescriptor( "Brep_With_Voids", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiBrep_with_voids );
    config_control_design::schema->AddEntity(config_control_design::e_brep_with_voids);
    config_control_design::e_connected_edge_set = new EntityDescriptor( "Connected_Edge_Set", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiConnected_edge_set );
    config_control_design::schema->AddEntity(config_control_design::e_connected_edge_set);
    config_control_design::e_alternate_product_relationship = new EntityDescriptor( "Alternate_Product_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAlternate_product_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_alternate_product_relationship);
    config_control_design::e_surface_of_linear_extrusion = new EntityDescriptor( "Surface_Of_Linear_Extrusion", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSurface_of_linear_extrusion );
    config_control_design::schema->AddEntity(config_control_design::e_surface_of_linear_extrusion);
    config_control_design::e_security_classification = new EntityDescriptor( "Security_Classification", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSecurity_classification );
    config_control_design::schema->AddEntity(config_control_design::e_security_classification);
    config_control_design::e_certification_type = new EntityDescriptor( "Certification_Type", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiCertification_type );
    config_control_design::schema->AddEntity(config_control_design::e_certification_type);
    config_control_design::e_approval_date_time = new EntityDescriptor( "Approval_Date_Time", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiApproval_date_time );
    config_control_design::schema->AddEntity(config_control_design::e_approval_date_time);
    config_control_design::e_point_on_curve = new EntityDescriptor( "Point_On_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiPoint_on_curve );
    config_control_design::schema->AddEntity(config_control_design::e_point_on_curve);
    config_control_design::e_intersection_curve = new EntityDescriptor( "Intersection_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiIntersection_curve );
    config_control_design::schema->AddEntity(config_control_design::e_intersection_curve);
    config_control_design::e_action_directive = new EntityDescriptor( "Action_Directive", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAction_directive );
    config_control_design::schema->AddEntity(config_control_design::e_action_directive);
    config_control_design::e_offset_curve_3d = new EntityDescriptor( "Offset_Curve_3d", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOffset_curve_3d );
    config_control_design::schema->AddEntity(config_control_design::e_offset_curve_3d);
    config_control_design::e_area_unit = new EntityDescriptor( "Area_Unit", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiArea_unit );
    config_control_design::schema->AddEntity(config_control_design::e_area_unit);
    config_control_design::e_oriented_open_shell = new EntityDescriptor( "Oriented_Open_Shell", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiOriented_open_shell );
    config_control_design::schema->AddEntity(config_control_design::e_oriented_open_shell);
    config_control_design::e_shell_based_wireframe_shape_representation = new EntityDescriptor( "Shell_Based_Wireframe_Shape_Representation", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiShell_based_wireframe_shape_representation );
    config_control_design::schema->AddEntity(config_control_design::e_shell_based_wireframe_shape_representation);
    config_control_design::e_advanced_face = new EntityDescriptor( "Advanced_Face", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiAdvanced_face );
    config_control_design::schema->AddEntity(config_control_design::e_advanced_face);
    config_control_design::e_date_time_role = new EntityDescriptor( "Date_Time_Role", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDate_time_role );
    config_control_design::schema->AddEntity(config_control_design::e_date_time_role);
    config_control_design::e_document_type = new EntityDescriptor( "Document_Type", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiDocument_type );
    config_control_design::schema->AddEntity(config_control_design::e_document_type);
    config_control_design::e_supplied_part_relationship = new EntityDescriptor( "Supplied_Part_Relationship", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSupplied_part_relationship );
    config_control_design::schema->AddEntity(config_control_design::e_supplied_part_relationship);
    config_control_design::e_conical_surface = new EntityDescriptor( "Conical_Surface", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiConical_surface );
    config_control_design::schema->AddEntity(config_control_design::e_conical_surface);
    config_control_design::e_edge_curve = new EntityDescriptor( "Edge_Curve", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiEdge_curve );
    config_control_design::schema->AddEntity(config_control_design::e_edge_curve);
    config_control_design::e_serial_numbered_effectivity = new EntityDescriptor( "Serial_Numbered_Effectivity", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiSerial_numbered_effectivity );
    config_control_design::schema->AddEntity(config_control_design::e_serial_numbered_effectivity);
    config_control_design::e_wire_shell = new EntityDescriptor( "Wire_Shell", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiWire_shell );
    config_control_design::schema->AddEntity(config_control_design::e_wire_shell);
    config_control_design::e_mechanical_context = new EntityDescriptor( "Mechanical_Context", config_control_design::schema, LFalse, LFalse, (Creator) create_SdaiMechanical_context );
    config_control_design::schema->AddEntity(config_control_design::e_mechanical_context);
//////////////// USE statements
//////////////// REFERENCE statements
}

#endif
