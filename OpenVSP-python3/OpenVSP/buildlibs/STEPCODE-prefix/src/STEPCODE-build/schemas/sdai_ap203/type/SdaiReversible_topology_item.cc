#ifndef  TYPE_SDAIREVERSIBLE_TOPOLOGY_ITEM_CC
#define  TYPE_SDAIREVERSIBLE_TOPOLOGY_ITEM_CC

// This file was generated by exp2cxx,
// git commit id: 0.8, build timestamp 03 Nov 2020 03:17.
// You probably don't want to edit it since your modifications
// will be lost if exp2cxx is used to regenerate it.

#include "schema.h"
#include "sc_memmgr.h"
#include "type/SdaiReversible_topology_item.h"


//////////  SELECT TYPE reversible_topology_item

const TypeDescriptor * 
SdaiReversible_topology_item::AssignEntity (SDAI_Application_instance * se)
{
  (void)se;
  //  EDGE
  if (se -> IsA (config_control_design::e_edge))
  {  
    _app_inst = (SdaiEdge_ptr) se;
    return SetUnderlyingType (config_control_design::e_edge);
  }
  //  PATH
  if (se -> IsA (config_control_design::e_path))
  {  
    _app_inst = (SdaiPath_ptr) se;
    return SetUnderlyingType (config_control_design::e_path);
  }
  //  FACE
  if (se -> IsA (config_control_design::e_face))
  {  
    _app_inst = (SdaiFace_ptr) se;
    return SetUnderlyingType (config_control_design::e_face);
  }
  //  FACE_BOUND
  if (se -> IsA (config_control_design::e_face_bound))
  {  
    _app_inst = (SdaiFace_bound_ptr) se;
    return SetUnderlyingType (config_control_design::e_face_bound);
  }
  //  CLOSED_SHELL
  if (se -> IsA (config_control_design::e_closed_shell))
  {  
    _app_inst = (SdaiClosed_shell_ptr) se;
    return SetUnderlyingType (config_control_design::e_closed_shell);
  }
  //  OPEN_SHELL
  if (se -> IsA (config_control_design::e_open_shell))
  {  
    _app_inst = (SdaiOpen_shell_ptr) se;
    return SetUnderlyingType (config_control_design::e_open_shell);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  std::cerr << se -> EntityName () << std::endl;
#endif
  return 0;
}

SDAI_Select * 
SdaiReversible_topology_item::NewSelect ()
{
    SdaiReversible_topology_item * tmp = new SdaiReversible_topology_item();
    return tmp;
}


// STEP Part 21

void
SdaiReversible_topology_item::STEPwrite_content (ostream& out, const char * currSch) const {
  (void)currSch;
      if (CurrentUnderlyingType () == config_control_design::e_edge) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_path) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_face) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_face_bound) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_closed_shell) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_open_shell) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
}

BASE_TYPE
SdaiReversible_topology_item::ValueType() const {
    if (CurrentUnderlyingType() == config_control_design::e_edge)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_path)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_face)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_face_bound)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_closed_shell)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_open_shell)
        return sdaiINSTANCE;
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
    return (BASE_TYPE)0;
}

void
SdaiReversible_topology_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
    const TypeDescriptor *td = CurrentUnderlyingType();
    std::string tmp;

    if ( td ) {
        // If we have a legal underlying type, get its name acc
        // to the current schema.
        StrToUpper( td->Name(currSch), tmp );
    }
    if (td == config_control_design::e_edge) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_path) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_face) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_face_bound) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_closed_shell) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_open_shell) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
    return;
}

Severity
SdaiReversible_topology_item::STEPread_content (istream& in, InstMgrBase * instances,
            const char *utype, int addFileId, const char *currSch)
{
  (void)instances;
  (void)utype;
  (void)addFileId;
  (void)currSch;
      if (CurrentUnderlyingType () == config_control_design::e_edge) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_path) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_face) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_face_bound) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_closed_shell) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_open_shell) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
    return severity ();
}

Severity
SdaiReversible_topology_item::StrToVal_content (const char * str, InstMgrBase * instances)
{
  (void)str;
  (void)instances;
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
std::cerr << str << "  " << instances << std::endl;
#endif
    return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

    //  part 0
SdaiReversible_topology_item::SdaiReversible_topology_item( const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript)
{
#ifdef SC_LOGGING
    if( *logStream )
    {
    *logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << std::endl;
    }
#endif
   nullify();
#ifdef SC_LOGGING
    if( *logStream )
    {
//    *logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << std::endl;
    }
#endif
}

    //  part 1
SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiEdge_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_edge)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << std::endl; }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiPath_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_path)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << std::endl; }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiFace_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_face)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << std::endl; }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiFace_bound_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_face_bound)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << std::endl; }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiClosed_shell_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_closed_shell)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << std::endl; }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiOpen_shell_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_open_shell)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << std::endl; }
#endif
}

SdaiReversible_topology_item::~SdaiReversible_topology_item() {
}

SdaiReversible_topology_item_agg::SdaiReversible_topology_item_agg( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiReversible_topology_item_agg::~SdaiReversible_topology_item_agg() { }


    //  part 2
SdaiReversible_topology_item::operator SdaiEdge_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_edge )
      return ((SdaiEdge_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiPath_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_path )
      return ((SdaiPath_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiFace_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_face )
      return ((SdaiFace_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiFace_bound_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_face_bound )
      return ((SdaiFace_bound_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiClosed_shell_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_closed_shell )
      return ((SdaiClosed_shell_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiOpen_shell_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_open_shell )
      return ((SdaiOpen_shell_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


    //  part 3

EntityAggregate_ptr SdaiReversible_topology_item::cfs_faces_() {
  if( CurrentUnderlyingType () == config_control_design::e_closed_shell ) 
    //  CLOSED_SHELL
    return ((SdaiClosed_shell_ptr) _app_inst) ->cfs_faces_();
  if( CurrentUnderlyingType () == config_control_design::e_open_shell ) 
    //  OPEN_SHELL
    return ((SdaiOpen_shell_ptr) _app_inst) ->cfs_faces_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


EntityAggregate_ptr_c SdaiReversible_topology_item::cfs_faces_() const {
  if( CurrentUnderlyingType () == config_control_design::e_closed_shell ) 
    //  CLOSED_SHELL
    return ((const SdaiClosed_shell_ptr) _app_inst) ->cfs_faces_();
  if( CurrentUnderlyingType () == config_control_design::e_open_shell ) 
    //  OPEN_SHELL
    return ((const SdaiOpen_shell_ptr) _app_inst) ->cfs_faces_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiReversible_topology_item::cfs_faces_( const EntityAggregate_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_closed_shell ) 
    //  CLOSED_SHELL
    {  ((SdaiClosed_shell_ptr) _app_inst) ->cfs_faces_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_open_shell ) 
    //  OPEN_SHELL
    {  ((SdaiOpen_shell_ptr) _app_inst) ->cfs_faces_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

Boolean SdaiReversible_topology_item::orientation_() const {
  if( CurrentUnderlyingType () == config_control_design::e_face_bound ) 
    //  FACE_BOUND
    return ((SdaiFace_bound_ptr) _app_inst) ->orientation_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return (Boolean) 0;
}


void SdaiReversible_topology_item::orientation_( const Boolean x ) {
  if( CurrentUnderlyingType () == config_control_design::e_face_bound ) 
    //  FACE_BOUND
    {  ((SdaiFace_bound_ptr) _app_inst) ->orientation_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiLoop_ptr SdaiReversible_topology_item::bound_() {
  if( CurrentUnderlyingType () == config_control_design::e_face_bound ) 
    //  FACE_BOUND
    return ((SdaiFace_bound_ptr) _app_inst) ->bound_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiLoop_ptr_c SdaiReversible_topology_item::bound_() const {
  if( CurrentUnderlyingType () == config_control_design::e_face_bound ) 
    //  FACE_BOUND
    return ((const SdaiFace_bound_ptr) _app_inst) ->bound_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiReversible_topology_item::bound_( const SdaiLoop_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_face_bound ) 
    //  FACE_BOUND
    {  ((SdaiFace_bound_ptr) _app_inst) ->bound_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

EntityAggregate_ptr SdaiReversible_topology_item::bounds_() {
  if( CurrentUnderlyingType () == config_control_design::e_face ) 
    //  FACE
    return ((SdaiFace_ptr) _app_inst) ->bounds_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


EntityAggregate_ptr_c SdaiReversible_topology_item::bounds_() const {
  if( CurrentUnderlyingType () == config_control_design::e_face ) 
    //  FACE
    return ((const SdaiFace_ptr) _app_inst) ->bounds_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiReversible_topology_item::bounds_( const EntityAggregate_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_face ) 
    //  FACE
    {  ((SdaiFace_ptr) _app_inst) ->bounds_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

EntityAggregate_ptr SdaiReversible_topology_item::edge_list_() {
  if( CurrentUnderlyingType () == config_control_design::e_path ) 
    //  PATH
    return ((SdaiPath_ptr) _app_inst) ->edge_list_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


EntityAggregate_ptr_c SdaiReversible_topology_item::edge_list_() const {
  if( CurrentUnderlyingType () == config_control_design::e_path ) 
    //  PATH
    return ((const SdaiPath_ptr) _app_inst) ->edge_list_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiReversible_topology_item::edge_list_( const EntityAggregate_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_path ) 
    //  PATH
    {  ((SdaiPath_ptr) _app_inst) ->edge_list_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiVertex_ptr SdaiReversible_topology_item::edge_end_() {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    return ((SdaiEdge_ptr) _app_inst) ->edge_end_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiVertex_ptr_c SdaiReversible_topology_item::edge_end_() const {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    return ((const SdaiEdge_ptr) _app_inst) ->edge_end_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiReversible_topology_item::edge_end_( const SdaiVertex_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    {  ((SdaiEdge_ptr) _app_inst) ->edge_end_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiVertex_ptr SdaiReversible_topology_item::edge_start_() {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    return ((SdaiEdge_ptr) _app_inst) ->edge_start_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiVertex_ptr_c SdaiReversible_topology_item::edge_start_() const {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    return ((const SdaiEdge_ptr) _app_inst) ->edge_start_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiReversible_topology_item::edge_start_( const SdaiVertex_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    {  ((SdaiEdge_ptr) _app_inst) ->edge_start_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiLabel SdaiReversible_topology_item::name_() {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    return ((SdaiEdge_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_path ) 
    //  PATH
    return ((SdaiPath_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_face ) 
    //  FACE
    return ((SdaiFace_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_face_bound ) 
    //  FACE_BOUND
    return ((SdaiFace_bound_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_closed_shell ) 
    //  CLOSED_SHELL
    return ((SdaiClosed_shell_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_open_shell ) 
    //  OPEN_SHELL
    return ((SdaiOpen_shell_ptr) _app_inst) ->name_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


const SdaiLabel SdaiReversible_topology_item::name_() const {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    return ((const SdaiEdge_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_path ) 
    //  PATH
    return ((const SdaiPath_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_face ) 
    //  FACE
    return ((const SdaiFace_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_face_bound ) 
    //  FACE_BOUND
    return ((const SdaiFace_bound_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_closed_shell ) 
    //  CLOSED_SHELL
    return ((const SdaiClosed_shell_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_open_shell ) 
    //  OPEN_SHELL
    return ((const SdaiOpen_shell_ptr) _app_inst) ->name_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiReversible_topology_item::name_( const SdaiLabel x ) {
  if( CurrentUnderlyingType () == config_control_design::e_edge ) 
    //  EDGE
    {  ((SdaiEdge_ptr) _app_inst) ->name_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_path ) 
    //  PATH
    {  ((SdaiPath_ptr) _app_inst) ->name_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_face ) 
    //  FACE
    {  ((SdaiFace_ptr) _app_inst) ->name_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_face_bound ) 
    //  FACE_BOUND
    {  ((SdaiFace_bound_ptr) _app_inst) ->name_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_closed_shell ) 
    //  CLOSED_SHELL
    {  ((SdaiClosed_shell_ptr) _app_inst) ->name_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_open_shell ) 
    //  OPEN_SHELL
    {  ((SdaiOpen_shell_ptr) _app_inst) ->name_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

    //  part 4
SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiEdge_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_edge );
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiPath_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_path );
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiFace_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_face );
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiFace_bound_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_face_bound );
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiClosed_shell_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_closed_shell );
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiOpen_shell_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_open_shell );
   return *this;
}


#ifndef COMPILER_DEFINES_OPERATOR_EQ

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiReversible_topology_item_ptr& o ) {
    SDAI_Select::operator=( *o );
    if ( o -> CurrentUnderlyingType() == config_control_design::e_edge ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_path ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_face ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_face_bound ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_closed_shell ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_open_shell ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    return *this;
}

SDAI_Select& SdaiReversible_topology_item::operator =( const SDAI_Select& o ) {
    SDAI_Select::operator=( o );
    if ( o.CurrentUnderlyingType() == config_control_design::e_edge ) {
        _app_inst = ( ( SdaiReversible_topology_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_path ) {
        _app_inst = ( ( SdaiReversible_topology_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_face ) {
        _app_inst = ( ( SdaiReversible_topology_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_face_bound ) {
        _app_inst = ( ( SdaiReversible_topology_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_closed_shell ) {
        _app_inst = ( ( SdaiReversible_topology_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_open_shell ) {
        _app_inst = ( ( SdaiReversible_topology_item& ) o )._app_inst;
        return *this;
    }
   return *this;
}

#endif //ndef COMPILER_DEFINES_OPERATOR_EQ

    //  part 5
Logical SdaiReversible_topology_item::IsEdge() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_edge )
      return LTrue;
   return LFalse;
}

Logical SdaiReversible_topology_item::IsPath() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_path )
      return LTrue;
   return LFalse;
}

Logical SdaiReversible_topology_item::IsFace() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_face )
      return LTrue;
   return LFalse;
}

Logical SdaiReversible_topology_item::IsFace_bound() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_face_bound )
      return LTrue;
   return LFalse;
}

Logical SdaiReversible_topology_item::IsClosed_shell() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_closed_shell )
      return LTrue;
   return LFalse;
}

Logical SdaiReversible_topology_item::IsOpen_shell() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_open_shell )
      return LTrue;
   return LFalse;
}

//////////  END SELECT TYPE SdaiReversible_topology_item


void init_SdaiReversible_topology_item( Registry& reg ) {
    std::string str;
        config_control_design::t_reversible_topology_item = new SelectTypeDescriptor (
                  ~(sdaiINSTANCE),        //unique elements,
                  "Reversible_Topology_Item",        // Name
                  sdaiSELECT,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "SELECT (Edge, Path, Face, Face_Bound, Closed_Shell, Open_Shell)",        // Description
                  (SelectCreator) create_SdaiReversible_topology_item);        // Creator function
        config_control_design::schema->AddType(config_control_design::t_reversible_topology_item);
    config_control_design::t_reversible_topology_item -> Elements ().AddNode (config_control_design::e_edge);
    config_control_design::t_reversible_topology_item -> Elements ().AddNode (config_control_design::e_path);
    config_control_design::t_reversible_topology_item -> Elements ().AddNode (config_control_design::e_face);
    config_control_design::t_reversible_topology_item -> Elements ().AddNode (config_control_design::e_face_bound);
    config_control_design::t_reversible_topology_item -> Elements ().AddNode (config_control_design::e_closed_shell);
    config_control_design::t_reversible_topology_item -> Elements ().AddNode (config_control_design::e_open_shell);
    reg.AddType (*config_control_design::t_reversible_topology_item);
}

#endif
