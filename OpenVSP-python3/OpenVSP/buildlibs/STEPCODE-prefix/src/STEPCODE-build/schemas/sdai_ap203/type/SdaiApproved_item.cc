#ifndef  TYPE_SDAIAPPROVED_ITEM_CC
#define  TYPE_SDAIAPPROVED_ITEM_CC

// This file was generated by exp2cxx,
// git commit id: 0.8, build timestamp 03 Nov 2020 03:17.
// You probably don't want to edit it since your modifications
// will be lost if exp2cxx is used to regenerate it.

#include "schema.h"
#include "sc_memmgr.h"
#include "type/SdaiApproved_item.h"


//////////  SELECT TYPE approved_item

const TypeDescriptor * 
SdaiApproved_item::AssignEntity (SDAI_Application_instance * se)
{
  (void)se;
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> IsA (config_control_design::e_product_definition_formation))
  {  
    _app_inst = (SdaiProduct_definition_formation_ptr) se;
    return SetUnderlyingType (config_control_design::e_product_definition_formation);
  }
  //  PRODUCT_DEFINITION
  if (se -> IsA (config_control_design::e_product_definition))
  {  
    _app_inst = (SdaiProduct_definition_ptr) se;
    return SetUnderlyingType (config_control_design::e_product_definition);
  }
  //  CONFIGURATION_EFFECTIVITY
  if (se -> IsA (config_control_design::e_configuration_effectivity))
  {  
    _app_inst = (SdaiConfiguration_effectivity_ptr) se;
    return SetUnderlyingType (config_control_design::e_configuration_effectivity);
  }
  //  CONFIGURATION_ITEM
  if (se -> IsA (config_control_design::e_configuration_item))
  {  
    _app_inst = (SdaiConfiguration_item_ptr) se;
    return SetUnderlyingType (config_control_design::e_configuration_item);
  }
  //  SECURITY_CLASSIFICATION
  if (se -> IsA (config_control_design::e_security_classification))
  {  
    _app_inst = (SdaiSecurity_classification_ptr) se;
    return SetUnderlyingType (config_control_design::e_security_classification);
  }
  //  CHANGE_REQUEST
  if (se -> IsA (config_control_design::e_change_request))
  {  
    _app_inst = (SdaiChange_request_ptr) se;
    return SetUnderlyingType (config_control_design::e_change_request);
  }
  //  CHANGE
  if (se -> IsA (config_control_design::e_change))
  {  
    _app_inst = (SdaiChange_ptr) se;
    return SetUnderlyingType (config_control_design::e_change);
  }
  //  START_REQUEST
  if (se -> IsA (config_control_design::e_start_request))
  {  
    _app_inst = (SdaiStart_request_ptr) se;
    return SetUnderlyingType (config_control_design::e_start_request);
  }
  //  START_WORK
  if (se -> IsA (config_control_design::e_start_work))
  {  
    _app_inst = (SdaiStart_work_ptr) se;
    return SetUnderlyingType (config_control_design::e_start_work);
  }
  //  CERTIFICATION
  if (se -> IsA (config_control_design::e_certification))
  {  
    _app_inst = (SdaiCertification_ptr) se;
    return SetUnderlyingType (config_control_design::e_certification);
  }
  //  CONTRACT
  if (se -> IsA (config_control_design::e_contract))
  {  
    _app_inst = (SdaiContract_ptr) se;
    return SetUnderlyingType (config_control_design::e_contract);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  std::cerr << se -> EntityName () << std::endl;
#endif
  return 0;
}

SDAI_Select * 
SdaiApproved_item::NewSelect ()
{
    SdaiApproved_item * tmp = new SdaiApproved_item();
    return tmp;
}


// STEP Part 21

void
SdaiApproved_item::STEPwrite_content (ostream& out, const char * currSch) const {
  (void)currSch;
      if (CurrentUnderlyingType () == config_control_design::e_product_definition_formation) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_product_definition) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_configuration_effectivity) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_configuration_item) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_security_classification) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_change_request) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_change) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_start_request) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_start_work) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_certification) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    if (CurrentUnderlyingType () == config_control_design::e_contract) {
        _app_inst -> STEPwrite_reference (out);
        return;
    }
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
}

BASE_TYPE
SdaiApproved_item::ValueType() const {
    if (CurrentUnderlyingType() == config_control_design::e_product_definition_formation)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_product_definition)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_configuration_effectivity)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_configuration_item)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_security_classification)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_change_request)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_change)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_start_request)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_start_work)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_certification)
        return sdaiINSTANCE;
    if (CurrentUnderlyingType() == config_control_design::e_contract)
        return sdaiINSTANCE;
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
    return (BASE_TYPE)0;
}

void
SdaiApproved_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
    const TypeDescriptor *td = CurrentUnderlyingType();
    std::string tmp;

    if ( td ) {
        // If we have a legal underlying type, get its name acc
        // to the current schema.
        StrToUpper( td->Name(currSch), tmp );
    }
    if (td == config_control_design::e_product_definition_formation) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_product_definition) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_configuration_effectivity) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_configuration_item) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_security_classification) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_change_request) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_change) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_start_request) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_start_work) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_certification) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    if (td == config_control_design::e_contract) {
        out <<  tmp << "(";
        _app_inst -> STEPwrite_reference (out);
        out << ")";
        return;
    }
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
    return;
}

Severity
SdaiApproved_item::STEPread_content (istream& in, InstMgrBase * instances,
            const char *utype, int addFileId, const char *currSch)
{
  (void)instances;
  (void)utype;
  (void)addFileId;
  (void)currSch;
      if (CurrentUnderlyingType () == config_control_design::e_product_definition_formation) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_product_definition) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_configuration_effectivity) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_configuration_item) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_security_classification) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_change_request) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_change) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_start_request) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_start_work) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_certification) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }
    if (CurrentUnderlyingType () == config_control_design::e_contract) {
        // set Underlying Type in Select class
        _app_inst = ReadEntityRef(in, &_error, ",)", instances, addFileId);
        if( _app_inst && ( _app_inst != S_ENTITY_NULL) &&
               ( CurrentUnderlyingType()->CanBe( _app_inst->getEDesc() ) ) ) {
            return severity();
        } else {
             Error ("Reference to instance that is not indicated type\n");
            _app_inst = 0;
            nullify ();
            return severity (SEVERITY_USERMSG);
        }
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
    return severity ();
}

Severity
SdaiApproved_item::StrToVal_content (const char * str, InstMgrBase * instances)
{
  (void)str;
  (void)instances;
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
std::cerr << str << "  " << instances << std::endl;
#endif
    return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

    //  part 0
SdaiApproved_item::SdaiApproved_item( const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript)
{
#ifdef SC_LOGGING
    if( *logStream )
    {
    *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl;
    }
#endif
   nullify();
#ifdef SC_LOGGING
    if( *logStream )
    {
//    *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl;
    }
#endif
}

    //  part 1
SdaiApproved_item::SdaiApproved_item( const SdaiProduct_definition_formation_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_product_definition_formation)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiProduct_definition_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_product_definition)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiConfiguration_effectivity_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_configuration_effectivity)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiConfiguration_item_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_configuration_item)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiSecurity_classification_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_security_classification)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiChange_request_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_change_request)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiChange_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_change)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiStart_request_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_start_request)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiStart_work_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_start_work)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiCertification_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_certification)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiContract_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SDAI_Select (typedescript, config_control_design::e_contract)
{
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR entering SdaiApproved_item constructor." << std::endl; }
#endif
   _app_inst = o;
#ifdef SC_LOGGING
    if( *logStream ) { *logStream << "DAVE ERR exiting SdaiApproved_item constructor." << std::endl; }
#endif
}

SdaiApproved_item::~SdaiApproved_item() {
}

SdaiApproved_item_agg::SdaiApproved_item_agg( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiApproved_item_agg::~SdaiApproved_item_agg() { }


    //  part 2
SdaiApproved_item::operator SdaiProduct_definition_formation_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation )
      return ((SdaiProduct_definition_formation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiProduct_definition_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_product_definition )
      return ((SdaiProduct_definition_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiConfiguration_effectivity_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity )
      return ((SdaiConfiguration_effectivity_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiConfiguration_item_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_configuration_item )
      return ((SdaiConfiguration_item_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiSecurity_classification_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_security_classification )
      return ((SdaiSecurity_classification_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiChange_request_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_change_request )
      return ((SdaiChange_request_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiChange_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_change )
      return ((SdaiChange_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiStart_request_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_start_request )
      return ((SdaiStart_request_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiStart_work_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_start_work )
      return ((SdaiStart_work_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiCertification_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_certification )
      return ((SdaiCertification_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiContract_ptr()
{
   if( CurrentUnderlyingType () == config_control_design::e_contract )
      return ((SdaiContract_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


    //  part 3

SdaiCertification_type_ptr SdaiApproved_item::kind_() {
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    return ((SdaiCertification_ptr) _app_inst) ->kind_();
  //  CONTRACT
    //  attribute access function has a different return type
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiCertification_type_ptr_c SdaiApproved_item::kind_() const {
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    return ((const SdaiCertification_ptr) _app_inst) ->kind_();
  //  CONTRACT
    //  attribute access function has a different return type
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::kind_( const SdaiCertification_type_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    {  ((SdaiCertification_ptr) _app_inst) ->kind_( x );
      return;
    }
  //  for CONTRACT  attribute access function has a different argument type

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiAction_ptr SdaiApproved_item::assigned_action_() {
  if( CurrentUnderlyingType () == config_control_design::e_change ) 
    //  CHANGE
    return ((SdaiChange_ptr) _app_inst) ->assigned_action_();
  if( CurrentUnderlyingType () == config_control_design::e_start_work ) 
    //  START_WORK
    return ((SdaiStart_work_ptr) _app_inst) ->assigned_action_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiAction_ptr_c SdaiApproved_item::assigned_action_() const {
  if( CurrentUnderlyingType () == config_control_design::e_change ) 
    //  CHANGE
    return ((const SdaiChange_ptr) _app_inst) ->assigned_action_();
  if( CurrentUnderlyingType () == config_control_design::e_start_work ) 
    //  START_WORK
    return ((const SdaiStart_work_ptr) _app_inst) ->assigned_action_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::assigned_action_( const SdaiAction_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_change ) 
    //  CHANGE
    {  ((SdaiChange_ptr) _app_inst) ->assigned_action_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_start_work ) 
    //  START_WORK
    {  ((SdaiStart_work_ptr) _app_inst) ->assigned_action_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiChange_request_item_agg_ptr SdaiApproved_item::items_() {
  if( CurrentUnderlyingType () == config_control_design::e_change_request ) 
    //  CHANGE_REQUEST
    return ((SdaiChange_request_ptr) _app_inst) ->items_();
  //  CHANGE
    //  attribute access function has a different return type
  //  START_REQUEST
    //  attribute access function has a different return type
  //  START_WORK
    //  attribute access function has a different return type
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiChange_request_item_agg_ptr_c SdaiApproved_item::items_() const {
  if( CurrentUnderlyingType () == config_control_design::e_change_request ) 
    //  CHANGE_REQUEST
    return ((const SdaiChange_request_ptr) _app_inst) ->items_();
  //  CHANGE
    //  attribute access function has a different return type
  //  START_REQUEST
    //  attribute access function has a different return type
  //  START_WORK
    //  attribute access function has a different return type
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::items_( const SdaiChange_request_item_agg_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_change_request ) 
    //  CHANGE_REQUEST
    {  ((SdaiChange_request_ptr) _app_inst) ->items_( x );
      return;
    }
  //  for CHANGE  attribute access function has a different argument type
  //  for START_REQUEST  attribute access function has a different argument type
  //  for START_WORK  attribute access function has a different argument type

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiVersioned_action_request_ptr SdaiApproved_item::assigned_action_request_() {
  if( CurrentUnderlyingType () == config_control_design::e_change_request ) 
    //  CHANGE_REQUEST
    return ((SdaiChange_request_ptr) _app_inst) ->assigned_action_request_();
  if( CurrentUnderlyingType () == config_control_design::e_start_request ) 
    //  START_REQUEST
    return ((SdaiStart_request_ptr) _app_inst) ->assigned_action_request_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiVersioned_action_request_ptr_c SdaiApproved_item::assigned_action_request_() const {
  if( CurrentUnderlyingType () == config_control_design::e_change_request ) 
    //  CHANGE_REQUEST
    return ((const SdaiChange_request_ptr) _app_inst) ->assigned_action_request_();
  if( CurrentUnderlyingType () == config_control_design::e_start_request ) 
    //  START_REQUEST
    return ((const SdaiStart_request_ptr) _app_inst) ->assigned_action_request_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::assigned_action_request_( const SdaiVersioned_action_request_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_change_request ) 
    //  CHANGE_REQUEST
    {  ((SdaiChange_request_ptr) _app_inst) ->assigned_action_request_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_start_request ) 
    //  START_REQUEST
    {  ((SdaiStart_request_ptr) _app_inst) ->assigned_action_request_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiSecurity_classification_level_ptr SdaiApproved_item::security_level_() {
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    return ((SdaiSecurity_classification_ptr) _app_inst) ->security_level_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiSecurity_classification_level_ptr_c SdaiApproved_item::security_level_() const {
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    return ((const SdaiSecurity_classification_ptr) _app_inst) ->security_level_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::security_level_( const SdaiSecurity_classification_level_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    {  ((SdaiSecurity_classification_ptr) _app_inst) ->security_level_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiLabel SdaiApproved_item::purpose_() {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((SdaiConfiguration_item_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    return ((SdaiSecurity_classification_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    return ((SdaiCertification_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_design::e_contract ) 
    //  CONTRACT
    return ((SdaiContract_ptr) _app_inst) ->purpose_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


const SdaiLabel SdaiApproved_item::purpose_() const {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((const SdaiConfiguration_item_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    return ((const SdaiSecurity_classification_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    return ((const SdaiCertification_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_design::e_contract ) 
    //  CONTRACT
    return ((const SdaiContract_ptr) _app_inst) ->purpose_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::purpose_( const SdaiLabel x ) {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    {  ((SdaiConfiguration_item_ptr) _app_inst) ->purpose_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    {  ((SdaiSecurity_classification_ptr) _app_inst) ->purpose_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    {  ((SdaiCertification_ptr) _app_inst) ->purpose_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_contract ) 
    //  CONTRACT
    {  ((SdaiContract_ptr) _app_inst) ->purpose_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiProduct_concept_ptr SdaiApproved_item::item_concept_() {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((SdaiConfiguration_item_ptr) _app_inst) ->item_concept_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiProduct_concept_ptr_c SdaiApproved_item::item_concept_() const {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((const SdaiConfiguration_item_ptr) _app_inst) ->item_concept_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::item_concept_( const SdaiProduct_concept_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    {  ((SdaiConfiguration_item_ptr) _app_inst) ->item_concept_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiLabel SdaiApproved_item::name_() {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((SdaiConfiguration_item_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    return ((SdaiSecurity_classification_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    return ((SdaiCertification_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_contract ) 
    //  CONTRACT
    return ((SdaiContract_ptr) _app_inst) ->name_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


const SdaiLabel SdaiApproved_item::name_() const {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((const SdaiConfiguration_item_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    return ((const SdaiSecurity_classification_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    return ((const SdaiCertification_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_design::e_contract ) 
    //  CONTRACT
    return ((const SdaiContract_ptr) _app_inst) ->name_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::name_( const SdaiLabel x ) {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    {  ((SdaiConfiguration_item_ptr) _app_inst) ->name_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_security_classification ) 
    //  SECURITY_CLASSIFICATION
    {  ((SdaiSecurity_classification_ptr) _app_inst) ->name_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_certification ) 
    //  CERTIFICATION
    {  ((SdaiCertification_ptr) _app_inst) ->name_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_contract ) 
    //  CONTRACT
    {  ((SdaiContract_ptr) _app_inst) ->name_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiConfiguration_design_ptr SdaiApproved_item::configuration_() {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    return ((SdaiConfiguration_effectivity_ptr) _app_inst) ->configuration_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiConfiguration_design_ptr_c SdaiApproved_item::configuration_() const {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    return ((const SdaiConfiguration_effectivity_ptr) _app_inst) ->configuration_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::configuration_( const SdaiConfiguration_design_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    {  ((SdaiConfiguration_effectivity_ptr) _app_inst) ->configuration_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiProduct_definition_relationship_ptr SdaiApproved_item::usage_() {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    return ((SdaiConfiguration_effectivity_ptr) _app_inst) ->usage_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiProduct_definition_relationship_ptr_c SdaiApproved_item::usage_() const {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    return ((const SdaiConfiguration_effectivity_ptr) _app_inst) ->usage_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::usage_( const SdaiProduct_definition_relationship_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    {  ((SdaiConfiguration_effectivity_ptr) _app_inst) ->usage_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiProduct_definition_context_ptr SdaiApproved_item::frame_of_reference_() {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    return ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiProduct_definition_context_ptr_c SdaiApproved_item::frame_of_reference_() const {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    return ((const SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::frame_of_reference_( const SdaiProduct_definition_context_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    {  ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiProduct_definition_formation_ptr SdaiApproved_item::formation_() {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    return ((SdaiProduct_definition_ptr) _app_inst) ->formation_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiProduct_definition_formation_ptr_c SdaiApproved_item::formation_() const {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    return ((const SdaiProduct_definition_ptr) _app_inst) ->formation_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::formation_( const SdaiProduct_definition_formation_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    {  ((SdaiProduct_definition_ptr) _app_inst) ->formation_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiProduct_ptr SdaiApproved_item::of_product_() {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    return ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


SdaiProduct_ptr_c SdaiApproved_item::of_product_() const {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    return ((const SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::of_product_( const SdaiProduct_ptr x ) {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    {  ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiText SdaiApproved_item::description_() {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    return ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    return ((SdaiProduct_definition_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((SdaiConfiguration_item_ptr) _app_inst) ->description_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


const SdaiText SdaiApproved_item::description_() const {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    return ((const SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    return ((const SdaiProduct_definition_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((const SdaiConfiguration_item_ptr) _app_inst) ->description_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::description_( const SdaiText x ) {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    {  ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    {  ((SdaiProduct_definition_ptr) _app_inst) ->description_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    {  ((SdaiConfiguration_item_ptr) _app_inst) ->description_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

SdaiIdentifier SdaiApproved_item::id_() {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    return ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    return ((SdaiProduct_definition_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    return ((SdaiConfiguration_effectivity_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((SdaiConfiguration_item_ptr) _app_inst) ->id_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


const SdaiIdentifier SdaiApproved_item::id_() const {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    return ((const SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    return ((const SdaiProduct_definition_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    return ((const SdaiConfiguration_effectivity_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    return ((const SdaiConfiguration_item_ptr) _app_inst) ->id_();
    std::cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
    << _POC_ << "\n\n";
   return 0;
}


void SdaiApproved_item::id_( const SdaiIdentifier x ) {
  if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation ) 
    //  PRODUCT_DEFINITION_FORMATION
    {  ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_product_definition ) 
    //  PRODUCT_DEFINITION
    {  ((SdaiProduct_definition_ptr) _app_inst) ->id_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity ) 
    //  CONFIGURATION_EFFECTIVITY
    {  ((SdaiConfiguration_effectivity_ptr) _app_inst) ->id_( x );
      return;
    }
  if( CurrentUnderlyingType () == config_control_design::e_configuration_item ) 
    //  CONFIGURATION_ITEM
    {  ((SdaiConfiguration_item_ptr) _app_inst) ->id_( x );
      return;
    }

   severity( SEVERITY_WARNING );
   std::cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

    //  part 4
SdaiApproved_item& SdaiApproved_item::operator =( const SdaiProduct_definition_formation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_product_definition_formation );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiProduct_definition_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_product_definition );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiConfiguration_effectivity_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_configuration_effectivity );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiConfiguration_item_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_configuration_item );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiSecurity_classification_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_security_classification );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiChange_request_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_change_request );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiChange_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_change );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiStart_request_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_start_request );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiStart_work_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_start_work );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiCertification_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_certification );
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiContract_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType( config_control_design::e_contract );
   return *this;
}


#ifndef COMPILER_DEFINES_OPERATOR_EQ

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiApproved_item_ptr& o ) {
    SDAI_Select::operator=( *o );
    if ( o -> CurrentUnderlyingType() == config_control_design::e_product_definition_formation ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_product_definition ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_configuration_effectivity ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_configuration_item ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_security_classification ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_change_request ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_change ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_start_request ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_start_work ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_certification ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    if ( o -> CurrentUnderlyingType() == config_control_design::e_contract ) {
        _app_inst =  o -> _app_inst;
        return *this;
    }
    return *this;
}

SDAI_Select& SdaiApproved_item::operator =( const SDAI_Select& o ) {
    SDAI_Select::operator=( o );
    if ( o.CurrentUnderlyingType() == config_control_design::e_product_definition_formation ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_product_definition ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_configuration_effectivity ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_configuration_item ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_security_classification ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_change_request ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_change ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_start_request ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_start_work ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_certification ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
    if ( o.CurrentUnderlyingType() == config_control_design::e_contract ) {
        _app_inst = ( ( SdaiApproved_item& ) o )._app_inst;
        return *this;
    }
   return *this;
}

#endif //ndef COMPILER_DEFINES_OPERATOR_EQ

    //  part 5
Logical SdaiApproved_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_product_definition_formation )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsProduct_definition() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_product_definition )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsConfiguration_effectivity() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_configuration_effectivity )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsConfiguration_item() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_configuration_item )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsSecurity_classification() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_security_classification )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsChange_request() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_change_request )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsChange() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_change )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsStart_request() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_start_request )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsStart_work() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_start_work )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsCertification() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_certification )
      return LTrue;
   return LFalse;
}

Logical SdaiApproved_item::IsContract() const
{
   if( !exists() )
      return LUnknown;
   if( CurrentUnderlyingType () == config_control_design::e_contract )
      return LTrue;
   return LFalse;
}

//////////  END SELECT TYPE SdaiApproved_item


void init_SdaiApproved_item( Registry& reg ) {
    std::string str;
        config_control_design::t_approved_item = new SelectTypeDescriptor (
                  ~(sdaiINSTANCE),        //unique elements,
                  "Approved_Item",        // Name
                  sdaiSELECT,        // FundamentalType
                  config_control_design::schema,        // Originating Schema
                  "SELECT (Product_Definition_Formation, Product_Definition, Configuration_Effectivity, Configuration_Item, Security_Classification, Change_Request, Change, Start_Request, Start_Work, Certification, Contract)",        // Description
                  (SelectCreator) create_SdaiApproved_item);        // Creator function
        config_control_design::schema->AddType(config_control_design::t_approved_item);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_product_definition_formation);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_product_definition);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_configuration_effectivity);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_configuration_item);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_security_classification);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_change_request);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_change);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_start_request);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_start_work);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_certification);
    config_control_design::t_approved_item -> Elements ().AddNode (config_control_design::e_contract);
    reg.AddType (*config_control_design::t_approved_item);
}

#endif
