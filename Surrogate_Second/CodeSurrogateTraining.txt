import pandas as pd
import numpy as np
import pylab as plt
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.neural_network import MLPRegressor
from sklearn.metrics import confusion_matrix
from sklearn.metrics import mean_squared_error
from pandas.plotting import scatter_matrix


def main():   
    vel_sound_range = [325.0, 345.0] #(m/s)
    rho_range       = [0.85, 1.3]
    alpha_range     = [0.0, 20.0] #ยบ
    mach_range      = [0.0, 0.3] 
    rpm_range       = [0.0, 6000.0]
    cp_range        = [0.0, 0.8]
    ct_range        = [0.0, 0.5]
    flap_range      = [0.0, 30.0] #ยบ



    x_data = pd.read_csv("x_3.csv")
    x_data = x_data[['vel_sound','rho', 'alpha', 'mach', 'rpm', 'cp', 'ct', 'flap']]

    cd_data = pd.read_csv("CD_3.csv")
    cd_data = cd_data[['CD']]

    cl_data = pd.read_csv("CL_3.csv")
    cl_data = cl_data[['CL']]

    #sc = StandardScaler()
    #x_data = sc.fit_transform(x_data)

    #Normalize data between 0 and 1

    x_data.values[:,0]=x_data.values[:,0]/vel_sound_range[1]
    x_data.values[:,1]=x_data.values[:,1]/rho_range[1]
    x_data.values[:,2]=x_data.values[:,2]/alpha_range[1]
    #x_data.values[:,3]=x_data.values[:,3]/mach_range[1]
    x_data.values[:,4]=x_data.values[:,4]/rpm_range[1]
    #x_data.values[:,5]=x_data.values[:,5]/cp_range[1]
    #x_data.values[:,6]=x_data.values[:,6]/ct_range[1]
    x_data.values[:,7]=x_data.values[:,7]/flap_range[1]

    #Adding the ouptput to the x_data vector

    x_data['CL']=cl_data
    x_data['CD']=cd_data
    
    #Count number of outliers
    
    outliers = pd.DataFrame((x_data['CL'] > 4) | (x_data['CL'] < 0) | (x_data['CD'] > 0.4) | (x_data['CD'] < 0))
    outliers.describe()

    #print(outliers[False].value_counts())
    
    #Remove the outliers

    x_data_out = x_data.mask((x_data['CL'] > 4) | (x_data['CL'] < 0) | (x_data['CD'] > 0.4) | (x_data['CD'] < 0)).dropna()    
    
    #Splitting the dataset into training and validation sets

    training_set, validation_set = train_test_split(x_data_out, test_size = 0.2, random_state = 21)

    #classifying the predictors and target variables as X and Y

    X_train = training_set.iloc[:,0:-2].values
    Y_train_cl = training_set.iloc[:,-2].values
    Y_train_cd = training_set.iloc[:,-1].values

    X_val = validation_set.iloc[:,0:-2].values
    Y_val_cl = validation_set.iloc[:,-2].values
    Y_val_cd = validation_set.iloc[:,-1].values

    #Initializing the classifier

    regr_cl = MLPRegressor(activation= 'relu', solver='lbfgs', tol=1e-10, alpha=1e-10, max_iter=8500, random_state=1)
    regr_cd = MLPRegressor(activation= 'relu', solver='lbfgs', tol=1e-10, alpha=1e-10, max_iter=13500, random_state=1)

    #Fitting the training data

    regr_cl.fit(X_train, Y_train_cl)
    regr_cd.fit(X_train, Y_train_cd)

    #Predicting for the validation set

    y_pred_cl = regr_cl.predict(X_val)
    y_pred_cd = regr_cd.predict(X_val)

    #Calculating accuracy of model
    
    print("VALIDATION SET CL")
    print(Y_val_cl)
    
    print("PREDICTED CL")
    print(y_pred_cl)
    
    print("VALIDATION SET CD")
    print(Y_val_cd)
    
    print("PREDICTED CD")
    print(y_pred_cd)

    print("SCORE CL = ", regr_cl.score(X_val, Y_val_cl))
    print("SCORE CD = ", regr_cd.score(X_val, Y_val_cd))
    
    #print("ACCURACY CL = ", accuracy_average(Y_val_cl, y_pred_cl))
    #print("ACCURACY CD = ", accuracy_average(Y_val_cd, y_pred_cd))
    
    print("MSE CL = ", mean_squared_error(Y_val_cl, y_pred_cl, squared=True))
    print("MSE CD = ", mean_squared_error(Y_val_cd, y_pred_cd, squared=True))
    
    print("RMSE CL = ", mean_squared_error(Y_val_cl, y_pred_cl, squared=False))
    print("RMSE CD = ", mean_squared_error(Y_val_cd, y_pred_cd, squared=False))
    
    scatter_matrix(x_data_out, figsize=(15,10))
    
    plt.show()
    
    return



def accuracy_average(val,pred):
    
    data_len = len(val)
    i=0
    difference_per = np.zeros([data_len,1])
    
    while i<data_len:
        difference_per[i]=(pred[i]-val[i])/pred[i]
        i=i+1
    
    return np.mean(difference_per)


main()





